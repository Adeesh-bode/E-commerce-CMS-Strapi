import { jsx, jsxs } from "react/jsx-runtime";
import { auth, useCallbackRef, translatedErrors, useFetchClient, useQuery, Form, useNotification, useAppInfo, usePersistentState, useTracking, useGuidedTour, useAPIErrorHandler, getYupInnerErrors, useFocusWhenNavigate, pxToRem, LoadingIndicatorPage, TrackingProvider, prefixFileUrlWithBackendUrl, GuidedTourProvider as GuidedTourProvider$1, StrapiAppProvider, LibraryProvider, CustomFieldsProvider, AutoReloadOverlayBlockerProvider, OverlayBlockerProvider, NotificationsProvider, RBACContext, getFetchClient } from "@strapi/helper-plugin";
import { createRoot } from "react-dom/client";
import { Box, Flex, SingleSelect, SingleSelectOption, FieldAction, TextInput, Main, Typography, Checkbox, Button, Field, Portal, IconButton, FieldLabel, VisuallyHidden, FieldInput, Textarea, Grid, GridItem, HeaderLayout, ContentLayout, EmptyStateLayout, LinkButton, Select, Option, TextButton, SkipToContent, DesignSystemProvider, lightTheme, darkTheme } from "@strapi/design-system";
import invariant from "invariant";
import isFunction from "lodash/isFunction";
import merge from "lodash/merge";
import pick from "lodash/pick";
import { Helmet } from "react-helmet";
import { useLocation, Route, Redirect, useHistory, NavLink, useRouteMatch, Switch, BrowserRouter } from "react-router-dom";
import * as React from "react";
import { IntlProvider, useIntl } from "react-intl";
import { useDispatch, Provider, useSelector, useStore } from "react-redux";
import { createContext } from "@radix-ui/react-context";
import { Link } from "@strapi/design-system/v2";
import { Eye, EyeStriked, Cross, ArrowRight, EmptyPictures } from "@strapi/icons";
import { Formik, Form as Form$1 } from "formik";
import camelCase from "lodash/camelCase";
import { useMutation, useQuery as useQuery$1, QueryClient, QueryClientProvider } from "react-query";
import styled, { useTheme, createGlobalStyle } from "styled-components";
import * as yup from "yup";
import { ValidationError } from "yup";
import defaultsDeep from "lodash/defaultsDeep";
import omit from "lodash/omit";
import { parse } from "qs";
import produce from "immer";
import get from "lodash/get";
import set from "lodash/set";
import { createSelector, configureStore, combineReducers } from "@reduxjs/toolkit";
const styles = `
.strapi--root {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  background: #fff;
}

.strapi--no-js {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  font-family: helvetica, arial, sans-serif;
}
`;
const NoJavascript = () => {
  return /* @__PURE__ */ jsx("noscript", { children: /* @__PURE__ */ jsx("div", { className: "strapi--root", children: /* @__PURE__ */ jsxs("div", { className: "strapi--no-js", children: [
    /* @__PURE__ */ jsx("style", { type: "text/css", children: styles }),
    /* @__PURE__ */ jsx("h1", { children: "JavaScript disabled" }),
    /* @__PURE__ */ jsxs("p", { children: [
      "Please ",
      /* @__PURE__ */ jsx("a", { href: "https://www.enable-javascript.com/", children: "enable JavaScript" }),
      " in your browser and reload the page to proceed."
    ] })
  ] }) }) });
};
const globalStyles = `
  html,
  body,
  #strapi {
    height: 100%;
  }
  body {
    margin: 0;
    -webkit-font-smoothing: antialiased;
  }
`;
const DefaultDocument = () => {
  return /* @__PURE__ */ jsxs("html", { lang: "en", children: [
    /* @__PURE__ */ jsxs("head", { children: [
      /* @__PURE__ */ jsx("meta", { charSet: "utf-8" }),
      /* @__PURE__ */ jsx("meta", { name: "viewport", content: "width=device-width, initial-scale=1, viewport-fit=cover" }),
      /* @__PURE__ */ jsx("meta", { name: "robots", content: "noindex" }),
      /* @__PURE__ */ jsx("meta", { name: "referrer", content: "same-origin" }),
      /* @__PURE__ */ jsx("title", { children: "Strapi Admin" }),
      /* @__PURE__ */ jsx("style", { children: globalStyles })
    ] }),
    /* @__PURE__ */ jsxs("body", { children: [
      /* @__PURE__ */ jsx("div", { id: "strapi" }),
      /* @__PURE__ */ jsx(NoJavascript, {})
    ] })
  ] });
};
const __variableDynamicImportRuntimeHelper = (glob, path) => {
  const v = glob[path];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path)));
  });
};
const PrivateRoute = ({
  component: Component,
  path,
  ...rest
}) => {
  const { pathname, search } = useLocation();
  return /* @__PURE__ */ jsx(
    Route,
    {
      path,
      render: (props) => auth.getToken() !== null ? /* @__PURE__ */ jsx(Component, { ...rest, ...props }) : /* @__PURE__ */ jsx(
        Redirect,
        {
          to: {
            pathname: "/auth/login",
            search: pathname !== "/" ? `?redirectTo=${encodeURIComponent(`${pathname}${search}`)}` : void 0
          }
        }
      )
    }
  );
};
const ADMIN_PERMISSIONS_CE = {
  contentManager: {
    main: [],
    collectionTypesConfigurations: [
      {
        action: "plugin::content-manager.collection-types.configure-view",
        subject: null
      }
    ],
    componentsConfigurations: [
      {
        action: "plugin::content-manager.components.configure-layout",
        subject: null
      }
    ],
    singleTypesConfigurations: [
      {
        action: "plugin::content-manager.single-types.configure-view",
        subject: null
      }
    ]
  },
  marketplace: {
    main: [{ action: "admin::marketplace.read", subject: null }],
    read: [{ action: "admin::marketplace.read", subject: null }]
  },
  settings: {
    roles: {
      main: [
        { action: "admin::roles.create", subject: null },
        { action: "admin::roles.update", subject: null },
        { action: "admin::roles.read", subject: null },
        { action: "admin::roles.delete", subject: null }
      ],
      create: [{ action: "admin::roles.create", subject: null }],
      delete: [{ action: "admin::roles.delete", subject: null }],
      read: [{ action: "admin::roles.read", subject: null }],
      update: [{ action: "admin::roles.update", subject: null }]
    },
    users: {
      main: [
        { action: "admin::users.create", subject: null },
        { action: "admin::users.read", subject: null },
        { action: "admin::users.update", subject: null },
        { action: "admin::users.delete", subject: null }
      ],
      create: [{ action: "admin::users.create", subject: null }],
      delete: [{ action: "admin::users.delete", subject: null }],
      read: [{ action: "admin::users.read", subject: null }],
      update: [{ action: "admin::users.update", subject: null }]
    },
    webhooks: {
      main: [
        { action: "admin::webhooks.create", subject: null },
        { action: "admin::webhooks.read", subject: null },
        { action: "admin::webhooks.update", subject: null },
        { action: "admin::webhooks.delete", subject: null }
      ],
      create: [{ action: "admin::webhooks.create", subject: null }],
      delete: [{ action: "admin::webhooks.delete", subject: null }],
      read: [
        { action: "admin::webhooks.read", subject: null },
        // NOTE: We need to check with the API
        { action: "admin::webhooks.update", subject: null },
        { action: "admin::webhooks.delete", subject: null }
      ],
      update: [{ action: "admin::webhooks.update", subject: null }]
    },
    "api-tokens": {
      main: [{ action: "admin::api-tokens.access", subject: null }],
      create: [{ action: "admin::api-tokens.create", subject: null }],
      delete: [{ action: "admin::api-tokens.delete", subject: null }],
      read: [{ action: "admin::api-tokens.read", subject: null }],
      update: [{ action: "admin::api-tokens.update", subject: null }],
      regenerate: [{ action: "admin::api-tokens.regenerate", subject: null }]
    },
    "transfer-tokens": {
      main: [{ action: "admin::transfer.tokens.access", subject: null }],
      create: [{ action: "admin::transfer.tokens.create", subject: null }],
      delete: [{ action: "admin::transfer.tokens.delete", subject: null }],
      read: [{ action: "admin::transfer.tokens.read", subject: null }],
      update: [{ action: "admin::transfer.tokens.update", subject: null }],
      regenerate: [{ action: "admin::transfer.tokens.regenerate", subject: null }]
    },
    "project-settings": {
      read: [{ action: "admin::project-settings.read", subject: null }],
      update: [{ action: "admin::project-settings.update", subject: null }]
    }
  }
};
const HOOKS = {
  /**
   * Hook that allows to mutate the displayed headers of the list view table
   * @constant
   * @type {string}
   */
  INJECT_COLUMN_IN_TABLE: "Admin/CM/pages/ListView/inject-column-in-table",
  /**
   * Hook that allows to mutate the CM's collection types links pre-set filters
   * @constant
   * @type {string}
   */
  MUTATE_COLLECTION_TYPES_LINKS: "Admin/CM/pages/App/mutate-collection-types-links",
  /**
   * Hook that allows to mutate the CM's edit view layout
   * @constant
   * @type {string}
   */
  MUTATE_EDIT_VIEW_LAYOUT: "Admin/CM/pages/EditView/mutate-edit-view-layout",
  /**
   * Hook that allows to mutate the CM's single types links pre-set filters
   * @constant
   * @type {string}
   */
  MUTATE_SINGLE_TYPES_LINKS: "Admin/CM/pages/App/mutate-single-types-links"
};
const ACTION_SET_APP_RUNTIME_STATUS = "StrapiAdmin/APP/SET_APP_RUNTIME_STATUS";
const ACTION_SET_ADMIN_PERMISSIONS = "StrapiAdmin/App/SET_ADMIN_PERMISSIONS";
const SETTINGS_LINKS_CE = () => ({
  global: [
    {
      intlLabel: { id: "Settings.application.title", defaultMessage: "Overview" },
      to: "/settings/application-infos",
      id: "000-application-infos"
    },
    {
      intlLabel: { id: "Settings.webhooks.title", defaultMessage: "Webhooks" },
      to: "/settings/webhooks",
      id: "webhooks"
    },
    {
      intlLabel: { id: "Settings.apiTokens.title", defaultMessage: "API Tokens" },
      to: "/settings/api-tokens?sort=name:ASC",
      id: "api-tokens"
    },
    {
      intlLabel: { id: "Settings.transferTokens.title", defaultMessage: "Transfer Tokens" },
      to: "/settings/transfer-tokens?sort=name:ASC",
      id: "transfer-tokens"
    },
    // If the Enterprise feature is not enabled and if the config doesn't disable it, we promote the Enterprise feature by displaying them in the settings menu.
    // Disable this by adding "promoteEE: false" to your `./config/admin.js` file
    ...!window.strapi.features.isEnabled(window.strapi.features.SSO) && window.strapi?.flags?.promoteEE ? [
      {
        intlLabel: { id: "Settings.sso.title", defaultMessage: "Single Sign-On" },
        to: "/settings/purchase-single-sign-on",
        id: "sso",
        lockIcon: true
      }
    ] : [],
    ...!window.strapi.features.isEnabled(window.strapi.features.REVIEW_WORKFLOWS) && window.strapi?.flags?.promoteEE ? [
      {
        intlLabel: {
          id: "Settings.review-workflows.page.title",
          defaultMessage: "Review Workflows"
        },
        to: "/settings/purchase-review-workflows",
        id: "review-workflows",
        lockIcon: true
      }
    ] : []
  ],
  admin: [
    {
      intlLabel: { id: "global.roles", defaultMessage: "Roles" },
      to: "/settings/roles",
      id: "roles"
    },
    {
      intlLabel: { id: "global.users", defaultMessage: "Users" },
      // Init the search params directly
      to: "/settings/users?pageSize=10&page=1&sort=firstname",
      id: "users"
    },
    ...!window.strapi.features.isEnabled(window.strapi.features.AUDIT_LOGS) && window.strapi?.flags?.promoteEE ? [
      {
        intlLabel: { id: "global.auditLogs", defaultMessage: "Audit Logs" },
        to: "/settings/purchase-audit-logs",
        id: "auditLogs",
        lockIcon: true
      }
    ] : []
  ]
});
const [ConfigurationContextProvider, useConfigurationContext] = createContext("ConfigurationContext");
const useConfiguration = () => useConfigurationContext("useConfiguration");
function isEnterprise() {
  return window.strapi.isEE;
}
const useEnterprise = (ceData, eeCallback, opts = {}) => {
  const { defaultValue = null, combine = (_ceData, eeData) => eeData, enabled = true } = opts;
  const eeCallbackRef = useCallbackRef(eeCallback);
  const combineCallbackRef = useCallbackRef(combine);
  const [{ data }, setData] = React.useState({
    data: isEnterprise() && enabled ? defaultValue : ceData
  });
  React.useEffect(() => {
    async function importEE() {
      const eeData = await eeCallbackRef();
      const combinedValue = combineCallbackRef(ceData, eeData);
      setData({ data: combinedValue ? combinedValue : eeData });
    }
    if (isEnterprise() && enabled) {
      importEE();
    }
  }, [ceData, eeCallbackRef, combineCallbackRef, enabled]);
  return data;
};
const [LocalesContextProvider, useLocalesContext] = createContext("LocalesContext");
const useLocales = () => useLocalesContext("useLocales");
const LANGUAGE_LOCAL_STORAGE_KEY = "strapi-admin-language";
const LanguageProvider = ({ children, localeNames, messages }) => {
  const [{ locale }, dispatch] = React.useReducer(
    reducer$2,
    initialState$7,
    () => {
      const languageFromLocaleStorage = window.localStorage.getItem(LANGUAGE_LOCAL_STORAGE_KEY);
      if (languageFromLocaleStorage && localeNames[languageFromLocaleStorage]) {
        return {
          locale: languageFromLocaleStorage,
          localeNames
        };
      } else {
        return {
          locale: "en",
          localeNames
        };
      }
    }
  );
  React.useEffect(() => {
    window.localStorage.setItem(LANGUAGE_LOCAL_STORAGE_KEY, locale);
    document.documentElement.setAttribute("lang", locale);
  }, [locale]);
  const changeLocale = React.useCallback((locale2) => {
    dispatch({
      type: "CHANGE_LOCALE",
      locale: locale2
    });
  }, []);
  const appMessages = defaultsDeep(messages[locale], messages.en);
  return /* @__PURE__ */ jsx(IntlProvider, { locale, defaultLocale: "en", messages: appMessages, textComponent: "span", children: /* @__PURE__ */ jsx(LocalesContextProvider, { changeLocale, localeNames, children }) });
};
const initialState$7 = {
  localeNames: { en: "English" },
  locale: "en"
};
const reducer$2 = (state = initialState$7, action) => {
  switch (action.type) {
    case "CHANGE_LOCALE": {
      const { locale } = action;
      if (!state.localeNames[locale]) {
        return state;
      }
      return { ...state, locale };
    }
    default: {
      return state;
    }
  }
};
const Img = styled.img`
  height: ${72 / 16}rem;
`;
const Logo = () => {
  const {
    logos: { auth: auth2 }
  } = useConfiguration();
  return /* @__PURE__ */ jsx(Img, { src: auth2?.custom ?? auth2.default, "aria-hidden": true, alt: "" });
};
const Wrapper = styled(Box)`
  margin: 0 auto;
  width: 552px;
`;
const Column = styled(Flex)`
  flex-direction: column;
`;
const LocaleToggle = () => {
  const { changeLocale, localeNames } = useLocales();
  const { formatMessage, locale } = useIntl();
  return /* @__PURE__ */ jsx(
    SingleSelect,
    {
      "aria-label": formatMessage({
        id: "global.localeToggle.label",
        defaultMessage: "Select interface language"
      }),
      value: locale,
      onChange: (language) => {
        changeLocale(language);
      },
      children: Object.entries(localeNames).map(([language, name]) => /* @__PURE__ */ jsx(SingleSelectOption, { value: language, children: name }, language))
    }
  );
};
const LayoutContent = ({ children }) => /* @__PURE__ */ jsx(
  Wrapper,
  {
    shadow: "tableShadow",
    hasRadius: true,
    paddingTop: 9,
    paddingBottom: 9,
    paddingLeft: 10,
    paddingRight: 10,
    background: "neutral0",
    children
  }
);
const UnauthenticatedLayout = ({ children }) => {
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsx(Flex, { as: "header", justifyContent: "flex-end", children: /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingRight: 8, children: /* @__PURE__ */ jsx(LocaleToggle, {}) }) }),
    /* @__PURE__ */ jsx(Box, { paddingTop: 2, paddingBottom: 11, children })
  ] });
};
const FieldActionWrapper = styled(FieldAction)`
  svg {
    height: 1rem;
    width: 1rem;
    path {
      fill: ${({ theme }) => theme.colors.neutral600};
    }
  }
`;
const LOGIN_SCHEMA = yup.object().shape({
  email: yup.string().email(translatedErrors.email).required(translatedErrors.required),
  password: yup.string().required(translatedErrors.required),
  rememberMe: yup.bool().nullable()
});
const Login = ({ children }) => {
  const [apiError, setApiError] = React.useState();
  const [passwordShown, setPasswordShown] = React.useState(false);
  const { formatMessage } = useIntl();
  const { post } = useFetchClient();
  const { changeLocale } = useLocales();
  const query = useQuery();
  const { push } = useHistory();
  const mutation = useMutation(
    async (body) => {
      const {
        data: { data }
      } = await post("/admin/login", body);
      return { ...data, rememberMe: body.rememberMe };
    },
    {
      onSuccess(data) {
        if (data) {
          const { token, user } = data;
          if (user.preferedLanguage) {
            changeLocale(user.preferedLanguage);
          }
          auth.setToken(token, data.rememberMe);
          auth.setUserInfo(user, data.rememberMe);
          const redirectTo = query.get("redirectTo");
          const redirectUrl = redirectTo ? decodeURIComponent(redirectTo) : "/";
          push(redirectUrl);
        }
      },
      onError(err) {
        const message = err.response?.data?.error?.message ?? "Something went wrong";
        if (camelCase(message).toLowerCase() === "usernotactive") {
          push("/auth/oops");
          return;
        }
        setApiError(message);
      }
    }
  );
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(Main, { children: [
    /* @__PURE__ */ jsxs(LayoutContent, { children: [
      /* @__PURE__ */ jsxs(Column, { children: [
        /* @__PURE__ */ jsx(Logo, {}),
        /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingBottom: 1, children: /* @__PURE__ */ jsx(Typography, { variant: "alpha", as: "h1", children: formatMessage({
          id: "Auth.form.welcome.title",
          defaultMessage: "Welcome!"
        }) }) }),
        /* @__PURE__ */ jsx(Box, { paddingBottom: 7, children: /* @__PURE__ */ jsx(Typography, { variant: "epsilon", textColor: "neutral600", children: formatMessage({
          id: "Auth.form.welcome.subtitle",
          defaultMessage: "Log in to your Strapi account"
        }) }) }),
        mutation.isError && apiError ? /* @__PURE__ */ jsx(Typography, { id: "global-form-error", role: "alert", tabIndex: -1, textColor: "danger600", children: apiError }) : null
      ] }),
      /* @__PURE__ */ jsx(
        Formik,
        {
          enableReinitialize: true,
          initialValues: {
            email: "",
            password: "",
            rememberMe: false
          },
          onSubmit: (values) => {
            mutation.mutate(values);
          },
          validationSchema: LOGIN_SCHEMA,
          validateOnChange: false,
          children: ({ values, errors, handleChange }) => /* @__PURE__ */ jsx(Form, { children: /* @__PURE__ */ jsxs(Flex, { direction: "column", alignItems: "stretch", gap: 6, children: [
            /* @__PURE__ */ jsx(
              TextInput,
              {
                error: errors.email ? formatMessage({
                  id: errors.email,
                  defaultMessage: "This value is required."
                }) : "",
                value: values.email,
                onChange: handleChange,
                label: formatMessage({ id: "Auth.form.email.label", defaultMessage: "Email" }),
                placeholder: formatMessage({
                  id: "Auth.form.email.placeholder",
                  defaultMessage: "kai@doe.com"
                }),
                name: "email",
                required: true
              }
            ),
            /* @__PURE__ */ jsx(
              PasswordInput$2,
              {
                error: errors.password ? formatMessage({
                  id: errors.password,
                  defaultMessage: "This value is required."
                }) : "",
                onChange: handleChange,
                value: values.password,
                label: formatMessage({
                  id: "global.password",
                  defaultMessage: "Password"
                }),
                name: "password",
                type: passwordShown ? "text" : "password",
                endAction: /* @__PURE__ */ jsx(
                  FieldActionWrapper,
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      setPasswordShown((prev) => !prev);
                    },
                    label: formatMessage(
                      passwordShown ? {
                        id: "Auth.form.password.show-password",
                        defaultMessage: "Show password"
                      } : {
                        id: "Auth.form.password.hide-password",
                        defaultMessage: "Hide password"
                      }
                    ),
                    children: passwordShown ? /* @__PURE__ */ jsx(Eye, {}) : /* @__PURE__ */ jsx(EyeStriked, {})
                  }
                ),
                required: true
              }
            ),
            /* @__PURE__ */ jsx(
              Checkbox,
              {
                onValueChange: (checked) => {
                  handleChange({ target: { value: checked, name: "rememberMe" } });
                },
                value: values.rememberMe,
                "aria-label": "rememberMe",
                name: "rememberMe",
                children: formatMessage({
                  id: "Auth.form.rememberMe.label",
                  defaultMessage: "Remember me"
                })
              }
            ),
            /* @__PURE__ */ jsx(Button, { fullWidth: true, type: "submit", children: formatMessage({ id: "Auth.form.button.login", defaultMessage: "Login" }) })
          ] }) })
        }
      ),
      children
    ] }),
    /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Link, { as: NavLink, to: "/auth/forgot-password", children: formatMessage({
      id: "Auth.link.forgot-password",
      defaultMessage: "Forgot your password?"
    }) }) }) })
  ] }) });
};
const PasswordInput$2 = styled(TextInput)`
  ::-ms-reveal {
    display: none;
  }
`;
const ForgotPassword = () => {
  const { push } = useHistory();
  const { post } = useFetchClient();
  const { formatMessage } = useIntl();
  const { mutate, isError } = useMutation(
    async (body) => {
      await post("/admin/forgot-password", body);
    },
    {
      onSuccess() {
        push("/auth/forgot-password-success");
      }
    }
  );
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(Main, { children: [
    /* @__PURE__ */ jsxs(LayoutContent, { children: [
      /* @__PURE__ */ jsxs(Column, { children: [
        /* @__PURE__ */ jsx(Logo, {}),
        /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingBottom: 7, children: /* @__PURE__ */ jsx(Typography, { as: "h1", variant: "alpha", children: formatMessage({
          id: "Auth.form.button.password-recovery",
          defaultMessage: "Password Recovery"
        }) }) }),
        isError ? /* @__PURE__ */ jsx(Typography, { id: "global-form-error", role: "alert", tabIndex: -1, textColor: "danger600", children: formatMessage({
          id: "notification.error",
          defaultMessage: "An error occurred"
        }) }) : null
      ] }),
      /* @__PURE__ */ jsx(
        Formik,
        {
          enableReinitialize: true,
          initialValues: {
            email: ""
          },
          onSubmit: (values) => {
            mutate(values);
          },
          validationSchema: yup.object().shape({
            email: yup.string().email(translatedErrors.email).required(translatedErrors.required)
          }),
          validateOnChange: false,
          children: ({ values, errors, handleChange }) => /* @__PURE__ */ jsx(Form, { children: /* @__PURE__ */ jsxs(Flex, { direction: "column", alignItems: "stretch", gap: 6, children: [
            /* @__PURE__ */ jsx(
              TextInput,
              {
                error: errors.email ? formatMessage({
                  id: errors.email,
                  defaultMessage: "This email is invalid."
                }) : "",
                value: values.email,
                onChange: handleChange,
                label: formatMessage({ id: "Auth.form.email.label", defaultMessage: "Email" }),
                placeholder: formatMessage({
                  id: "Auth.form.email.placeholder",
                  defaultMessage: "kai@doe.com"
                }),
                name: "email",
                required: true
              }
            ),
            /* @__PURE__ */ jsx(Button, { type: "submit", fullWidth: true, children: formatMessage({
              id: "Auth.form.button.forgot-password",
              defaultMessage: "Send Email"
            }) })
          ] }) })
        }
      )
    ] }),
    /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Link, { as: NavLink, to: "/auth/login", children: formatMessage({ id: "Auth.link.ready", defaultMessage: "Ready to sign in?" }) }) }) })
  ] }) });
};
const ForgotPasswordSuccess = () => {
  const { formatMessage } = useIntl();
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(Main, { children: [
    /* @__PURE__ */ jsx(LayoutContent, { children: /* @__PURE__ */ jsxs(Column, { children: [
      /* @__PURE__ */ jsx(Logo, {}),
      /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingBottom: 7, children: /* @__PURE__ */ jsx(Typography, { as: "h1", variant: "alpha", children: formatMessage({
        id: "app.containers.AuthPage.ForgotPasswordSuccess.title",
        defaultMessage: "Email sent"
      }) }) }),
      /* @__PURE__ */ jsx(Typography, { children: formatMessage({
        id: "app.containers.AuthPage.ForgotPasswordSuccess.text.email",
        defaultMessage: "It can take a few minutes to receive your password recovery link."
      }) }),
      /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Typography, { children: formatMessage({
        id: "app.containers.AuthPage.ForgotPasswordSuccess.text.contact-admin",
        defaultMessage: "If you do not receive this link, please contact your administrator."
      }) }) })
    ] }) }),
    /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Link, { as: NavLink, to: "/auth/login", children: formatMessage({ id: "Auth.link.signin", defaultMessage: "Sign in" }) }) }) })
  ] }) });
};
const Oops = () => {
  const { formatMessage } = useIntl();
  const query = useQuery();
  const message = query.get("info") || formatMessage({
    id: "Auth.components.Oops.text",
    defaultMessage: "Your account has been suspended."
  });
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(Main, { children: [
    /* @__PURE__ */ jsx(LayoutContent, { children: /* @__PURE__ */ jsxs(Column, { children: [
      /* @__PURE__ */ jsx(Logo, {}),
      /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingBottom: 7, children: /* @__PURE__ */ jsx(Typography, { as: "h1", variant: "alpha", children: formatMessage({ id: "Auth.components.Oops.title", defaultMessage: "Oops..." }) }) }),
      /* @__PURE__ */ jsx(Typography, { children: message }),
      /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Typography, { children: formatMessage({
        id: "Auth.components.Oops.text.admin",
        defaultMessage: "If this is a mistake, please contact your administrator."
      }) }) })
    ] }) }),
    /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Link, { as: NavLink, to: "/auth/login", children: formatMessage({ id: "Auth.link.signin", defaultMessage: "Sign in" }) }) }) })
  ] }) });
};
const FieldWrapper = styled(Field)`
  height: ${32 / 16}rem;
  width: ${32 / 16}rem;

  > label,
  ~ input {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }

  > label {
    color: inherit;
    cursor: pointer;
    padding: ${({ theme }) => theme.spaces[2]};
    text-align: center;
    vertical-align: middle;
  }

  &:hover,
  &:focus-within {
    background-color: ${({ theme }) => theme.colors.neutral0};
  }

  &:active,
  &.selected {
    color: ${({ theme }) => theme.colors.primary700};
    background-color: ${({ theme }) => theme.colors.neutral0};
    border-color: ${({ theme }) => theme.colors.primary700};
  }
`;
const delays = {
  postResponse: 90 * 24 * 60 * 60 * 1e3,
  // 90 days in ms
  postFirstDismissal: 7 * 24 * 60 * 60 * 1e3,
  // 7 days in ms
  postSubsequentDismissal: 90 * 24 * 60 * 60 * 1e3,
  // 90 days in ms
  display: 5 * 60 * 1e3
  // 5 minutes in ms
};
const ratingArray = [...Array(11).keys()];
const checkIfShouldShowSurvey = (settings) => {
  const { enabled, lastResponseDate, firstDismissalDate, lastDismissalDate } = settings;
  if (window.strapi.flags.nps === false) {
    return false;
  }
  if (enabled === false) {
    return false;
  }
  if (lastResponseDate) {
    const timeSinceLastResponse = Date.now() - new Date(lastResponseDate).getTime();
    if (timeSinceLastResponse >= delays.postResponse) {
      return true;
    }
    return false;
  }
  if (lastDismissalDate) {
    const timeSinceLastDismissal = Date.now() - new Date(lastDismissalDate).getTime();
    if (timeSinceLastDismissal >= delays.postSubsequentDismissal) {
      return true;
    }
    return false;
  }
  if (firstDismissalDate) {
    const timeSinceFirstDismissal = Date.now() - new Date(firstDismissalDate).getTime();
    if (timeSinceFirstDismissal >= delays.postFirstDismissal) {
      return true;
    }
    return false;
  }
  return true;
};
const NpsSurvey = () => {
  const theme = useTheme();
  const { formatMessage } = useIntl();
  const { npsSurveySettings, setNpsSurveySettings } = useNpsSurveySettings();
  const [isFeedbackResponse, setIsFeedbackResponse] = React.useState(false);
  const toggleNotification = useNotification();
  const { currentEnvironment, strapiVersion } = useAppInfo();
  const { mutate, isLoading } = useMutation(
    async (form) => {
      const res = await fetch("https://analytics.strapi.io/submit-nps", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(form)
      });
      if (!res.ok) {
        throw new Error("Failed to submit NPS survey");
      }
      return res;
    },
    {
      onSuccess() {
        setNpsSurveySettings((settings) => ({
          ...settings,
          lastResponseDate: (/* @__PURE__ */ new Date()).toString(),
          firstDismissalDate: null,
          lastDismissalDate: null
        }));
        setIsFeedbackResponse(true);
        setTimeout(() => {
          setSurveyIsShown(false);
        }, 3e3);
      },
      onError() {
        toggleNotification({
          type: "warning",
          message: formatMessage({ id: "notification.error", defaultMessage: "An error occurred" })
        });
      }
    }
  );
  const [surveyIsShown, setSurveyIsShown] = React.useState(
    checkIfShouldShowSurvey(npsSurveySettings)
  );
  const [displaySurvey, setDisplaySurvey] = React.useState(false);
  React.useEffect(() => {
    const displayTime = setTimeout(() => {
      setDisplaySurvey(true);
    }, delays.display);
    return () => {
      clearTimeout(displayTime);
    };
  }, []);
  if (!displaySurvey) {
    return null;
  }
  if (!surveyIsShown) {
    return null;
  }
  const handleSubmitResponse = ({
    npsSurveyRating,
    npsSurveyFeedback
  }) => {
    const userInfo = auth.getUserInfo();
    mutate({
      email: typeof userInfo === "object" && userInfo !== null ? userInfo.email : "",
      rating: npsSurveyRating,
      comment: npsSurveyFeedback,
      environment: currentEnvironment,
      version: strapiVersion ?? void 0,
      license: window.strapi.projectType
    });
  };
  const handleDismiss = () => {
    setNpsSurveySettings((settings) => {
      const nextSettings = {
        ...settings,
        lastResponseDate: null
      };
      if (settings.firstDismissalDate) {
        nextSettings.lastDismissalDate = (/* @__PURE__ */ new Date()).toString();
      } else {
        nextSettings.firstDismissalDate = (/* @__PURE__ */ new Date()).toString();
      }
      return nextSettings;
    });
    setSurveyIsShown(false);
  };
  return /* @__PURE__ */ jsx(Portal, { children: /* @__PURE__ */ jsx(
    Formik,
    {
      initialValues: { npsSurveyFeedback: "", npsSurveyRating: null },
      onSubmit: handleSubmitResponse,
      validationSchema: yup.object({
        npsSurveyFeedback: yup.string(),
        npsSurveyRating: yup.number().required()
      }),
      children: ({ values, handleChange, setFieldValue }) => /* @__PURE__ */ jsx(Form$1, { name: "npsSurveyForm", children: /* @__PURE__ */ jsx(
        Flex,
        {
          hasRadius: true,
          direction: "column",
          padding: 4,
          borderColor: "primary200",
          background: "neutral0",
          shadow: "popupShadow",
          position: "fixed",
          bottom: 0,
          left: "50%",
          transform: "translateX(-50%)",
          zIndex: theme.zIndices[2],
          width: "50%",
          children: isFeedbackResponse ? /* @__PURE__ */ jsx(Typography, { fontWeight: "semiBold", children: formatMessage({
            id: "app.components.NpsSurvey.feedback-response",
            defaultMessage: "Thank you very much for your feedback!"
          }) }) : /* @__PURE__ */ jsxs(Box, { as: "fieldset", width: "100%", children: [
            /* @__PURE__ */ jsxs(Flex, { justifyContent: "space-between", width: "100%", children: [
              /* @__PURE__ */ jsx(Box, { marginLeft: "auto", marginRight: "auto", children: /* @__PURE__ */ jsx(Typography, { fontWeight: "semiBold", as: "legend", children: formatMessage({
                id: "app.components.NpsSurvey.banner-title",
                defaultMessage: "How likely are you to recommend Strapi to a friend or colleague?"
              }) }) }),
              /* @__PURE__ */ jsx(
                IconButton,
                {
                  onClick: handleDismiss,
                  "aria-label": formatMessage({
                    id: "app.components.NpsSurvey.dismiss-survey-label",
                    defaultMessage: "Dismiss survey"
                  }),
                  icon: /* @__PURE__ */ jsx(Cross, {})
                }
              )
            ] }),
            /* @__PURE__ */ jsxs(Flex, { gap: 2, marginTop: 2, marginBottom: 2, justifyContent: "center", children: [
              /* @__PURE__ */ jsx(Typography, { variant: "pi", textColor: "neutral600", children: formatMessage({
                id: "app.components.NpsSurvey.no-recommendation",
                defaultMessage: "Not at all likely"
              }) }),
              ratingArray.map((number) => {
                return /* @__PURE__ */ jsx(
                  FieldWrapper,
                  {
                    className: values.npsSurveyRating === number ? "selected" : void 0,
                    hasRadius: true,
                    background: "primary100",
                    borderColor: "primary200",
                    color: "primary600",
                    position: "relative",
                    cursor: "pointer",
                    children: /* @__PURE__ */ jsxs(FieldLabel, { htmlFor: `nps-survey-rating-${number}-input`, children: [
                      /* @__PURE__ */ jsx(VisuallyHidden, { children: /* @__PURE__ */ jsx(
                        FieldInput,
                        {
                          type: "radio",
                          id: `nps-survey-rating-${number}-input`,
                          name: "npsSurveyRating",
                          checked: values.npsSurveyRating === number,
                          onChange: (e) => setFieldValue("npsSurveyRating", parseInt(e.target.value, 10)),
                          value: number
                        }
                      ) }),
                      number
                    ] })
                  },
                  number
                );
              }),
              /* @__PURE__ */ jsx(Typography, { variant: "pi", textColor: "neutral600", children: formatMessage({
                id: "app.components.NpsSurvey.happy-to-recommend",
                defaultMessage: "Extremely likely"
              }) })
            ] }),
            values.npsSurveyRating !== null && /* @__PURE__ */ jsxs(Flex, { direction: "column", children: [
              /* @__PURE__ */ jsx(Box, { marginTop: 2, children: /* @__PURE__ */ jsx(FieldLabel, { htmlFor: "npsSurveyFeedback", fontWeight: "semiBold", fontSize: 2, children: formatMessage({
                id: "app.components.NpsSurvey.feedback-question",
                defaultMessage: "Do you have any suggestion for improvements?"
              }) }) }),
              /* @__PURE__ */ jsx(Box, { width: "62%", marginTop: 3, marginBottom: 4, children: /* @__PURE__ */ jsx(
                Textarea,
                {
                  id: "npsSurveyFeedback",
                  width: "100%",
                  onChange: handleChange,
                  children: values.npsSurveyFeedback
                }
              ) }),
              /* @__PURE__ */ jsx(Button, { marginBottom: 2, type: "submit", loading: isLoading, children: formatMessage({
                id: "app.components.NpsSurvey.submit-feedback",
                defaultMessage: "Submit Feedback"
              }) })
            ] })
          ] })
        }
      ) })
    }
  ) });
};
function useNpsSurveySettings() {
  const [npsSurveySettings, setNpsSurveySettings] = usePersistentState(
    "STRAPI_NPS_SURVEY_SETTINGS",
    {
      enabled: true,
      lastResponseDate: null,
      firstDismissalDate: null,
      lastDismissalDate: null
    }
  );
  return { npsSurveySettings, setNpsSurveySettings };
}
const REGISTER_USER_SCHEMA = yup.object().shape({
  firstname: yup.string().trim().required(translatedErrors.required),
  lastname: yup.string().nullable(),
  password: yup.string().min(8, translatedErrors.minLength).matches(/[a-z]/, "components.Input.error.contain.lowercase").matches(/[A-Z]/, "components.Input.error.contain.uppercase").matches(/\d/, "components.Input.error.contain.number").required(translatedErrors.required),
  confirmPassword: yup.string().oneOf([yup.ref("password"), null], "components.Input.error.password.noMatch").required(translatedErrors.required),
  registrationToken: yup.string().required(translatedErrors.required)
});
const REGISTER_ADMIN_SCHEMA = yup.object().shape({
  firstname: yup.string().trim().required(translatedErrors.required),
  lastname: yup.string().nullable(),
  password: yup.string().min(8, translatedErrors.minLength).matches(/[a-z]/, "components.Input.error.contain.lowercase").matches(/[A-Z]/, "components.Input.error.contain.uppercase").matches(/\d/, "components.Input.error.contain.number").required(translatedErrors.required),
  email: yup.string().email(translatedErrors.email).strict().lowercase(translatedErrors.lowercase).required(translatedErrors.required),
  confirmPassword: yup.string().oneOf([yup.ref("password"), null], "components.Input.error.password.noMatch").required(translatedErrors.required)
});
const Register = ({ hasAdmin }) => {
  const toggleNotification = useNotification();
  const { push } = useHistory();
  const [passwordShown, setPasswordShown] = React.useState(false);
  const [confirmPasswordShown, setConfirmPasswordShown] = React.useState(false);
  const [submitCount, setSubmitCount] = React.useState(0);
  const [apiError, setApiError] = React.useState();
  const { trackUsage } = useTracking();
  const { formatMessage } = useIntl();
  const { setSkipped } = useGuidedTour();
  const query = useQuery();
  const match = useRouteMatch(
    "/auth/:authType"
  );
  const { formatAPIError } = useAPIErrorHandler();
  const { get: get2, post } = useFetchClient();
  const { setNpsSurveySettings } = useNpsSurveySettings();
  const registrationToken = query.get("registrationToken");
  const { data: userInfo } = useQuery$1({
    queryKey: ["admin", "registration-info", registrationToken],
    async queryFn() {
      const {
        data: { data }
      } = await get2(`/admin/registration-info`, {
        params: {
          registrationToken
        }
      });
      return data;
    },
    enabled: !!registrationToken,
    initialData: {},
    onError(err) {
      const message = formatAPIError(err);
      toggleNotification({
        type: "warning",
        message
      });
      push(`/auth/oops?info=${encodeURIComponent(message)}`);
    }
  });
  const registerAdminMutation = useMutation(
    async (body) => {
      const { news, ...restBody } = body;
      const { data } = await post("/admin/register-admin", restBody);
      return { ...data.data, news };
    },
    {
      onSuccess(data) {
        const { token, user, news } = data;
        auth.setToken(token, false);
        auth.setUserInfo(user, false);
        const { roles } = user;
        if (roles) {
          const isUserSuperAdmin = roles.find(({ code }) => code === "strapi-super-admin");
          if (isUserSuperAdmin) {
            auth.set(false, "GUIDED_TOUR_SKIPPED", true);
            setSkipped(false);
            trackUsage("didLaunchGuidedtour");
          }
        }
        if (news) {
          setNpsSurveySettings((s) => ({ ...s, enabled: true }));
          push({
            pathname: "/usecase",
            search: `?hasAdmin=${true}`
          });
        } else {
          push("/");
        }
      },
      onError(err) {
        trackUsage("didNotCreateFirstAdmin");
        const error = formatAPIError(err);
        setApiError(error);
      }
    }
  );
  const registerUserMutation = useMutation(
    async (body) => {
      const { news, ...restBody } = body;
      const { data } = await post("/admin/register", restBody);
      return { ...data.data, news };
    },
    {
      onSuccess(data) {
        const { token, user, news } = data;
        auth.setToken(token, false);
        auth.setUserInfo(user, false);
        if (news) {
          setNpsSurveySettings((s) => ({ ...s, enabled: true }));
          push({
            pathname: "/usecase",
            search: `?hasAdmin=${hasAdmin}`
          });
        } else {
          push("/");
        }
      },
      onError(err) {
        trackUsage("didNotCreateFirstAdmin");
        const error = formatAPIError(err);
        setApiError(error);
      }
    }
  );
  if (!match || match.params.authType !== "register" && match.params.authType !== "register-admin") {
    return /* @__PURE__ */ jsx(Redirect, { to: "/" });
  }
  const isAdminRegistration = match.params.authType === "register-admin";
  const schema = isAdminRegistration ? REGISTER_ADMIN_SCHEMA : REGISTER_USER_SCHEMA;
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(LayoutContent, { children: [
    /* @__PURE__ */ jsxs(Flex, { direction: "column", alignItems: "center", gap: 3, children: [
      /* @__PURE__ */ jsx(Logo, {}),
      /* @__PURE__ */ jsx(Typography, { as: "h1", variant: "alpha", textAlign: "center", children: formatMessage({
        id: "Auth.form.welcome.title",
        defaultMessage: "Welcome to Strapi!"
      }) }),
      /* @__PURE__ */ jsx(Typography, { variant: "epsilon", textColor: "neutral600", textAlign: "center", children: formatMessage({
        id: "Auth.form.register.subtitle",
        defaultMessage: "Credentials are only used to authenticate in Strapi. All saved data will be stored in your database."
      }) }),
      apiError ? /* @__PURE__ */ jsx(Typography, { id: "global-form-error", role: "alert", tabIndex: -1, textColor: "danger600", children: apiError }) : null
    ] }),
    /* @__PURE__ */ jsx(
      Formik,
      {
        enableReinitialize: true,
        initialValues: {
          firstname: userInfo?.firstname || "",
          lastname: userInfo?.lastname || "",
          email: userInfo?.email || "",
          password: "",
          confirmPassword: "",
          registrationToken: registrationToken || void 0,
          news: false
        },
        onSubmit: async (data, formik) => {
          const normalizedData = normalizeData(data);
          try {
            await schema.validate(normalizedData, { abortEarly: false });
            if (submitCount > 0 && isAdminRegistration) {
              trackUsage("didSubmitWithErrorsFirstAdmin", { count: submitCount.toString() });
            }
            if (normalizedData.registrationToken) {
              registerUserMutation.mutate({
                userInfo: omit(normalizedData, [
                  "registrationToken",
                  "confirmPassword",
                  "email",
                  "news"
                ]),
                registrationToken: normalizedData.registrationToken,
                news: normalizedData.news
              });
            } else {
              registerAdminMutation.mutate(
                omit(normalizedData, ["registrationToken", "confirmPassword"])
              );
            }
          } catch (err) {
            if (err instanceof ValidationError) {
              const errors = getYupInnerErrors(err);
              formik.setErrors(errors);
            }
            setSubmitCount(submitCount + 1);
          }
        },
        validateOnChange: false,
        children: ({ values, errors, handleChange }) => {
          return /* @__PURE__ */ jsx(Form, { children: /* @__PURE__ */ jsx(Main, { children: /* @__PURE__ */ jsxs(Flex, { direction: "column", alignItems: "stretch", gap: 6, marginTop: 7, children: [
            /* @__PURE__ */ jsxs(Grid, { gap: 4, children: [
              /* @__PURE__ */ jsx(GridItem, { col: 6, children: /* @__PURE__ */ jsx(
                TextInput,
                {
                  name: "firstname",
                  required: true,
                  value: values.firstname,
                  error: errors.firstname ? formatMessage(errors.firstname) : void 0,
                  onChange: handleChange,
                  label: formatMessage({
                    id: "Auth.form.firstname.label",
                    defaultMessage: "Firstname"
                  })
                }
              ) }),
              /* @__PURE__ */ jsx(GridItem, { col: 6, children: /* @__PURE__ */ jsx(
                TextInput,
                {
                  name: "lastname",
                  value: values.lastname,
                  onChange: handleChange,
                  label: formatMessage({
                    id: "Auth.form.lastname.label",
                    defaultMessage: "Lastname"
                  })
                }
              ) })
            ] }),
            /* @__PURE__ */ jsx(
              TextInput,
              {
                name: "email",
                disabled: !isAdminRegistration,
                value: values.email,
                onChange: handleChange,
                error: errors.email ? formatMessage(errors.email) : void 0,
                required: true,
                label: formatMessage({
                  id: "Auth.form.email.label",
                  defaultMessage: "Email"
                }),
                type: "email"
              }
            ),
            /* @__PURE__ */ jsx(
              PasswordInput$1,
              {
                name: "password",
                onChange: handleChange,
                value: values.password,
                error: errors.password ? formatMessage(errors.password) : void 0,
                endAction: /* @__PURE__ */ jsx(
                  FieldActionWrapper,
                  {
                    onClick: (e) => {
                      e.preventDefault();
                      setPasswordShown((prev) => !prev);
                    },
                    label: formatMessage(
                      passwordShown ? {
                        id: "Auth.form.password.show-password",
                        defaultMessage: "Show password"
                      } : {
                        id: "Auth.form.password.hide-password",
                        defaultMessage: "Hide password"
                      }
                    ),
                    children: passwordShown ? /* @__PURE__ */ jsx(Eye, {}) : /* @__PURE__ */ jsx(EyeStriked, {})
                  }
                ),
                hint: formatMessage({
                  id: "Auth.form.password.hint",
                  defaultMessage: "Must be at least 8 characters, 1 uppercase, 1 lowercase & 1 number"
                }),
                required: true,
                label: formatMessage({
                  id: "global.password",
                  defaultMessage: "Password"
                }),
                type: passwordShown ? "text" : "password"
              }
            ),
            /* @__PURE__ */ jsx(
              PasswordInput$1,
              {
                name: "confirmPassword",
                onChange: handleChange,
                value: values.confirmPassword,
                error: errors.confirmPassword ? formatMessage(errors.confirmPassword) : void 0,
                endAction: /* @__PURE__ */ jsx(
                  FieldActionWrapper,
                  {
                    onClick: (e) => {
                      e.preventDefault();
                      setConfirmPasswordShown((prev) => !prev);
                    },
                    label: formatMessage(
                      confirmPasswordShown ? {
                        id: "Auth.form.password.show-password",
                        defaultMessage: "Show password"
                      } : {
                        id: "Auth.form.password.hide-password",
                        defaultMessage: "Hide password"
                      }
                    ),
                    children: confirmPasswordShown ? /* @__PURE__ */ jsx(Eye, {}) : /* @__PURE__ */ jsx(EyeStriked, {})
                  }
                ),
                required: true,
                label: formatMessage({
                  id: "Auth.form.confirmPassword.label",
                  defaultMessage: "Confirm Password"
                }),
                type: confirmPasswordShown ? "text" : "password"
              }
            ),
            /* @__PURE__ */ jsx(
              Checkbox,
              {
                onValueChange: (checked) => {
                  handleChange({ target: { value: checked, name: "news" } });
                },
                value: values.news,
                name: "news",
                "aria-label": "news",
                children: formatMessage(
                  {
                    id: "Auth.form.register.news.label",
                    defaultMessage: "Keep me updated about new features & upcoming improvements (by doing this you accept the {terms} and the {policy})."
                  },
                  {
                    terms: /* @__PURE__ */ jsx(A, { target: "_blank", href: "https://strapi.io/terms", rel: "noreferrer", children: formatMessage({
                      id: "Auth.privacy-policy-agreement.terms",
                      defaultMessage: "terms"
                    }) }),
                    policy: /* @__PURE__ */ jsx(A, { target: "_blank", href: "https://strapi.io/privacy", rel: "noreferrer", children: formatMessage({
                      id: "Auth.privacy-policy-agreement.policy",
                      defaultMessage: "policy"
                    }) })
                  }
                )
              }
            ),
            /* @__PURE__ */ jsx(Button, { fullWidth: true, size: "L", type: "submit", children: formatMessage({
              id: "Auth.form.button.register",
              defaultMessage: "Let's start"
            }) })
          ] }) }) });
        }
      }
    ),
    match?.params.authType === "register" && /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Link, { as: NavLink, to: "/auth/login", children: formatMessage({
      id: "Auth.link.signin.account",
      defaultMessage: "Already have an account?"
    }) }) }) })
  ] }) });
};
function normalizeData(data) {
  return Object.entries(data).reduce(
    (acc, [key, value]) => {
      if (!["password", "confirmPassword"].includes(key) && typeof value === "string") {
        acc[key] = value.trim();
        if (key === "lastname") {
          acc[key] = value || void 0;
        }
      } else {
        acc[key] = value;
      }
      return acc;
    },
    {}
  );
}
const A = styled.a`
  color: ${({ theme }) => theme.colors.primary600};
`;
const PasswordInput$1 = styled(TextInput)`
  ::-ms-reveal {
    display: none;
  }
`;
const RESET_PASSWORD_SCHEMA = yup.object().shape({
  password: yup.string().min(8, translatedErrors.minLength).matches(/[a-z]/, "components.Input.error.contain.lowercase").matches(/[A-Z]/, "components.Input.error.contain.uppercase").matches(/\d/, "components.Input.error.contain.number").required(translatedErrors.required),
  confirmPassword: yup.string().oneOf([yup.ref("password"), null], "components.Input.error.password.noMatch").required(translatedErrors.required)
});
const ResetPassword = () => {
  const [passwordShown, setPasswordShown] = React.useState(false);
  const [confirmPasswordShown, setConfirmPasswordShown] = React.useState(false);
  const { formatMessage } = useIntl();
  const { post } = useFetchClient();
  const { push } = useHistory();
  const query = useQuery();
  const { mutate, isError } = useMutation(
    async (body) => {
      const {
        data: { data }
      } = await post("/admin/reset-password", {
        ...body,
        resetPasswordToken: query.get("code")
      });
      return data;
    },
    {
      onSuccess(data) {
        if (data) {
          const { token, user } = data;
          auth.setToken(token, false);
          auth.setUserInfo(user, false);
          push("/");
        }
      }
    }
  );
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(Main, { children: [
    /* @__PURE__ */ jsxs(LayoutContent, { children: [
      /* @__PURE__ */ jsxs(Column, { children: [
        /* @__PURE__ */ jsx(Logo, {}),
        /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingBottom: 7, children: /* @__PURE__ */ jsx(Typography, { as: "h1", variant: "alpha", children: formatMessage({
          id: "global.reset-password",
          defaultMessage: "Reset password"
        }) }) }),
        isError ? /* @__PURE__ */ jsx(Typography, { id: "global-form-error", role: "alert", tabIndex: -1, textColor: "danger600", children: formatMessage({
          id: "notification.error",
          defaultMessage: "An error occurred"
        }) }) : null
      ] }),
      /* @__PURE__ */ jsx(
        Formik,
        {
          enableReinitialize: true,
          initialValues: {
            password: "",
            confirmPassword: ""
          },
          onSubmit: (values) => {
            mutate({ password: values.password });
          },
          validationSchema: RESET_PASSWORD_SCHEMA,
          validateOnChange: false,
          children: ({ values, errors, handleChange }) => /* @__PURE__ */ jsx(Form, { children: /* @__PURE__ */ jsxs(Flex, { direction: "column", alignItems: "stretch", gap: 6, children: [
            /* @__PURE__ */ jsx(
              PasswordInput,
              {
                name: "password",
                onChange: handleChange,
                value: values.password,
                error: errors.password ? formatMessage(
                  {
                    id: errors.password,
                    defaultMessage: "This field is required."
                  },
                  {
                    min: 8
                  }
                ) : void 0,
                endAction: /* @__PURE__ */ jsx(
                  FieldActionWrapper,
                  {
                    onClick: (e) => {
                      e.preventDefault();
                      setPasswordShown((prev) => !prev);
                    },
                    label: formatMessage(
                      passwordShown ? {
                        id: "Auth.form.password.show-password",
                        defaultMessage: "Show password"
                      } : {
                        id: "Auth.form.password.hide-password",
                        defaultMessage: "Hide password"
                      }
                    ),
                    children: passwordShown ? /* @__PURE__ */ jsx(Eye, {}) : /* @__PURE__ */ jsx(EyeStriked, {})
                  }
                ),
                hint: formatMessage({
                  id: "Auth.form.password.hint",
                  defaultMessage: "Password must contain at least 8 characters, 1 uppercase, 1 lowercase and 1 number"
                }),
                required: true,
                label: formatMessage({
                  id: "global.password",
                  defaultMessage: "Password"
                }),
                type: passwordShown ? "text" : "password"
              }
            ),
            /* @__PURE__ */ jsx(
              PasswordInput,
              {
                name: "confirmPassword",
                onChange: handleChange,
                value: values.confirmPassword,
                error: errors.confirmPassword ? formatMessage({
                  id: errors.confirmPassword,
                  defaultMessage: "This value is required."
                }) : void 0,
                endAction: /* @__PURE__ */ jsx(
                  FieldActionWrapper,
                  {
                    onClick: (e) => {
                      e.preventDefault();
                      setConfirmPasswordShown((prev) => !prev);
                    },
                    label: formatMessage(
                      passwordShown ? {
                        id: "Auth.form.password.show-password",
                        defaultMessage: "Show password"
                      } : {
                        id: "Auth.form.password.hide-password",
                        defaultMessage: "Hide password"
                      }
                    ),
                    children: confirmPasswordShown ? /* @__PURE__ */ jsx(Eye, {}) : /* @__PURE__ */ jsx(EyeStriked, {})
                  }
                ),
                required: true,
                label: formatMessage({
                  id: "Auth.form.confirmPassword.label",
                  defaultMessage: "Confirm Password"
                }),
                type: confirmPasswordShown ? "text" : "password"
              }
            ),
            /* @__PURE__ */ jsx(Button, { fullWidth: true, type: "submit", children: formatMessage({
              id: "global.change-password",
              defaultMessage: "Change password"
            }) })
          ] }) })
        }
      )
    ] }),
    /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(Link, { as: NavLink, to: "/auth/login", children: formatMessage({ id: "Auth.link.ready", defaultMessage: "Ready to sign in?" }) }) }) })
  ] }) });
};
const PasswordInput = styled(TextInput)`
  ::-ms-reveal {
    display: none;
  }
`;
const FORMS = {
  "forgot-password": ForgotPassword,
  "forgot-password-success": ForgotPasswordSuccess,
  // the `Component` attribute is set after all forms and CE/EE components are loaded, but since we
  // are here outside of a React component we can not use the hook directly
  login: () => null,
  oops: Oops,
  register: Register,
  "register-admin": Register,
  "reset-password": ResetPassword,
  providers: () => null
};
const AuthPage = ({ hasAdmin }) => {
  const {
    location: { search }
  } = useHistory();
  const match = useRouteMatch("/auth/:authType");
  const authType = match?.params.authType;
  const Login$1 = useEnterprise(
    Login,
    async () => (await import("./Login-d627bb0a.mjs")).LoginEE
  );
  const forms = useEnterprise(
    FORMS,
    async () => (await import("./constants-a6fd64fc.mjs")).FORMS,
    {
      combine(ceForms, eeForms) {
        return {
          ...ceForms,
          ...eeForms
        };
      },
      defaultValue: FORMS
    }
  );
  if (!authType || !forms) {
    return /* @__PURE__ */ jsx(Redirect, { to: "/" });
  }
  const Component = forms[authType];
  if (!Component || hasAdmin && authType === "register-admin" || auth.getToken()) {
    return /* @__PURE__ */ jsx(Redirect, { to: "/" });
  }
  if (!hasAdmin && authType !== "register-admin") {
    return /* @__PURE__ */ jsx(
      Redirect,
      {
        to: {
          pathname: "/auth/register-admin",
          // Forward the `?redirectTo` from /auth/login
          // /abc => /auth/login?redirectTo=%2Fabc => /auth/register-admin?redirectTo=%2Fabc
          search
        }
      }
    );
  }
  if (Login$1 && authType === "login") {
    return /* @__PURE__ */ jsx(Login$1, {});
  } else if (authType === "login" && !Login$1) {
    return null;
  }
  return /* @__PURE__ */ jsx(Component, { hasAdmin });
};
const NotFoundPage = () => {
  const { formatMessage } = useIntl();
  useFocusWhenNavigate();
  return /* @__PURE__ */ jsxs(Main, { labelledBy: "title", children: [
    /* @__PURE__ */ jsx(
      HeaderLayout,
      {
        id: "title",
        title: formatMessage({
          id: "content-manager.pageNotFound",
          defaultMessage: "Page not found"
        })
      }
    ),
    /* @__PURE__ */ jsx(ContentLayout, { children: /* @__PURE__ */ jsx(
      EmptyStateLayout,
      {
        action: /* @__PURE__ */ jsx(LinkButton, { variant: "secondary", endIcon: /* @__PURE__ */ jsx(ArrowRight, {}), to: "/", children: formatMessage({
          id: "app.components.NotFoundPage.back",
          defaultMessage: "Back to homepage"
        }) }),
        content: formatMessage({
          id: "app.page.not.found",
          defaultMessage: "Oops! We can't seem to find the page you're looging for..."
        }),
        hasRadius: true,
        icon: /* @__PURE__ */ jsx(EmptyPictures, { width: "10rem" }),
        shadow: "tableShadow"
      }
    ) })
  ] });
};
const NotFoundPage$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NotFoundPage
}, Symbol.toStringTag, { value: "Module" }));
const options = [
  {
    intlLabel: {
      id: "Usecase.front-end",
      defaultMessage: "Front-end developer"
    },
    value: "front_end_developer"
  },
  {
    intlLabel: {
      id: "Usecase.back-end",
      defaultMessage: "Back-end developer"
    },
    value: "back_end_developer"
  },
  {
    intlLabel: {
      id: "Usecase.full-stack",
      defaultMessage: "Full-stack developer"
    },
    value: "full_stack_developer"
  },
  {
    intlLabel: {
      id: "global.content-manager",
      defaultMessage: "Content Manager"
    },
    value: "content_manager"
  },
  {
    intlLabel: {
      id: "Usecase.content-creator",
      defaultMessage: "Content Creator"
    },
    value: "content_creator"
  },
  {
    intlLabel: {
      id: "Usecase.other",
      defaultMessage: "Other"
    },
    value: "other"
  }
];
const TypographyCenter = styled(Typography)`
  text-align: center;
`;
const UseCasePage = () => {
  const toggleNotification = useNotification();
  const { push, location } = useHistory();
  const { formatMessage } = useIntl();
  const [role, setRole] = React.useState(null);
  const [otherRole, setOtherRole] = React.useState("");
  const { post } = useFetchClient();
  const { firstname, email } = auth.get("userInfo") ?? {};
  const { hasAdmin } = parse(location?.search, { ignoreQueryPrefix: true });
  const isOther = role === "other";
  const handleSubmit = async (event, skipPersona) => {
    event.preventDefault();
    try {
      await post("https://analytics.strapi.io/register", {
        email,
        username: firstname,
        firstAdmin: Boolean(!hasAdmin),
        persona: {
          role: skipPersona ? void 0 : role,
          otherRole: skipPersona ? void 0 : otherRole
        }
      });
      toggleNotification({
        type: "success",
        message: {
          id: "Usecase.notification.success.project-created",
          defaultMessage: "Project has been successfully created"
        }
      });
      push("/");
    } catch (err) {
    }
  };
  return /* @__PURE__ */ jsx(UnauthenticatedLayout, { children: /* @__PURE__ */ jsxs(Main, { labelledBy: "usecase-title", children: [
    /* @__PURE__ */ jsx(LayoutContent, { children: /* @__PURE__ */ jsxs("form", { onSubmit: (e) => handleSubmit(e, false), children: [
      /* @__PURE__ */ jsxs(Flex, { direction: "column", paddingBottom: 7, children: [
        /* @__PURE__ */ jsx(Logo, {}),
        /* @__PURE__ */ jsx(Box, { paddingTop: 6, paddingBottom: 1, width: pxToRem(250), children: /* @__PURE__ */ jsx(TypographyCenter, { variant: "alpha", as: "h1", id: "usecase-title", children: formatMessage({
          id: "Usecase.title",
          defaultMessage: "Tell us a bit more about yourself"
        }) }) })
      ] }),
      /* @__PURE__ */ jsxs(Flex, { direction: "column", alignItems: "stretch", gap: 6, children: [
        /* @__PURE__ */ jsx(
          Select,
          {
            id: "usecase",
            "data-testid": "usecase",
            label: formatMessage({
              id: "Usecase.input.work-type",
              defaultMessage: "What type of work do you do?"
            }),
            onChange: (value) => setRole(value),
            value: role,
            children: options.map(({ intlLabel, value }) => /* @__PURE__ */ jsx(Option, { value, children: formatMessage(intlLabel) }, value))
          }
        ),
        isOther && /* @__PURE__ */ jsx(
          TextInput,
          {
            name: "other",
            label: formatMessage({ id: "Usecase.other", defaultMessage: "Other" }),
            value: otherRole,
            onChange: (e) => setOtherRole(e.target.value),
            "data-testid": "other"
          }
        ),
        /* @__PURE__ */ jsx(Button, { type: "submit", size: "L", fullWidth: true, disabled: !role, children: formatMessage({ id: "global.finish", defaultMessage: "Finish" }) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsx(Flex, { justifyContent: "center", children: /* @__PURE__ */ jsx(Box, { paddingTop: 4, children: /* @__PURE__ */ jsx(TextButton, { onClick: (event) => handleSubmit(event, true), children: formatMessage({
      id: "Usecase.button.skip",
      defaultMessage: "Skip this question"
    }) }) }) })
  ] }) });
};
const LazyCompo = ({ loadComponent }) => {
  const [Compo, setCompo] = React.useState(null);
  React.useEffect(() => {
    const loadCompo = async () => {
      try {
        const loadedCompo = await loadComponent();
        if (typeof loadedCompo === "function") {
          setCompo(() => loadedCompo);
        } else if (loadedCompo.default) {
          setCompo(() => loadedCompo.default);
        }
      } catch (err) {
      }
    };
    loadCompo();
  }, [loadComponent]);
  if (Compo) {
    return /* @__PURE__ */ jsx(Compo, {});
  }
  return /* @__PURE__ */ jsx(LoadingIndicatorPage, {});
};
const createRoute = (loadComponent, to, exact = false) => {
  return /* @__PURE__ */ jsx(
    Route,
    {
      render: () => /* @__PURE__ */ jsx(LazyCompo, { loadComponent }),
      path: to,
      exact: exact || false
    },
    to
  );
};
const ROUTES_CE = null;
const AuthenticatedApp = React.lazy(
  () => import("./AuthenticatedApp-bb31f306.mjs").then((n) => n.A).then((mod) => ({ default: mod.AuthenticatedApp }))
);
const App = () => {
  const adminPermissions = useEnterprise(
    ADMIN_PERMISSIONS_CE,
    async () => (await import("./constants-6ecddc43.mjs")).ADMIN_PERMISSIONS_EE,
    {
      combine(cePermissions, eePermissions) {
        return merge({}, cePermissions, eePermissions);
      },
      defaultValue: ADMIN_PERMISSIONS_CE
    }
  );
  const routes = useEnterprise(
    ROUTES_CE,
    async () => (await import("./constants-6ecddc43.mjs")).ROUTES_EE,
    {
      defaultValue: []
    }
  );
  const toggleNotification = useNotification();
  const { updateProjectSettings } = useConfiguration();
  const { formatMessage } = useIntl();
  const [{ isLoading, hasAdmin, uuid, deviceId }, setState] = React.useState({
    isLoading: true,
    deviceId: void 0,
    hasAdmin: false,
    uuid: false
  });
  const dispatch = useDispatch();
  const appInfo = useAppInfo();
  const { get: get2, post } = useFetchClient();
  const authRoutes = React.useMemo(() => {
    if (!routes) {
      return null;
    }
    return routes.map(({ to, Component, exact }) => createRoute(Component, to, exact));
  }, [routes]);
  const [telemetryProperties, setTelemetryProperties] = React.useState(void 0);
  React.useEffect(() => {
    dispatch({ type: ACTION_SET_ADMIN_PERMISSIONS, payload: adminPermissions });
  }, [adminPermissions, dispatch]);
  React.useEffect(() => {
    const currentToken = auth.getToken();
    const renewToken = async () => {
      try {
        const {
          data: {
            data: { token }
          }
        } = await post("/admin/renew-token", { token: currentToken });
        auth.updateToken(token);
      } catch (err) {
        auth.clearAppStorage();
        window.location.reload();
      }
    };
    if (currentToken) {
      renewToken();
    }
  }, [post]);
  React.useEffect(() => {
    const getData = async () => {
      try {
        const {
          data: {
            data: { hasAdmin: hasAdmin2, uuid: uuid2, menuLogo, authLogo }
          }
        } = await get2(`/admin/init`);
        updateProjectSettings({
          menuLogo: prefixFileUrlWithBackendUrl(menuLogo),
          authLogo: prefixFileUrlWithBackendUrl(authLogo)
        });
        if (uuid2) {
          const {
            data: { data: properties }
          } = await get2(`/admin/telemetry-properties`, {
            // NOTE: needed because the interceptors of the fetchClient redirect to /login when receive a 401 and it would end up in an infinite loop when the user doesn't have a session.
            validateStatus: (status) => status < 500
          });
          setTelemetryProperties(properties);
          try {
            const event = "didInitializeAdministration";
            await post(
              "https://analytics.strapi.io/api/v2/track",
              {
                // This event is anonymous
                event,
                userId: "",
                deviceId,
                eventPropeties: {},
                userProperties: { environment: appInfo.currentEnvironment },
                groupProperties: { ...properties, projectId: uuid2 }
              },
              {
                headers: {
                  "X-Strapi-Event": event
                }
              }
            );
          } catch (e) {
          }
        }
        setState({ isLoading: false, hasAdmin: hasAdmin2, uuid: uuid2, deviceId });
      } catch (err) {
        toggleNotification({
          type: "warning",
          message: { id: "app.containers.App.notification.error.init" }
        });
      }
    };
    getData();
  }, [toggleNotification, updateProjectSettings]);
  const trackingInfo = React.useMemo(
    () => ({
      uuid,
      telemetryProperties,
      deviceId
    }),
    [uuid, telemetryProperties, deviceId]
  );
  if (isLoading) {
    return /* @__PURE__ */ jsx(LoadingIndicatorPage, {});
  }
  return /* @__PURE__ */ jsxs(React.Suspense, { fallback: /* @__PURE__ */ jsx(LoadingIndicatorPage, {}), children: [
    /* @__PURE__ */ jsx(SkipToContent, { children: formatMessage({ id: "skipToContent", defaultMessage: "Skip to content" }) }),
    /* @__PURE__ */ jsx(TrackingProvider, { value: trackingInfo, children: /* @__PURE__ */ jsxs(Switch, { children: [
      authRoutes,
      /* @__PURE__ */ jsx(
        Route,
        {
          path: "/auth/:authType",
          render: (routerProps) => /* @__PURE__ */ jsx(AuthPage, { ...routerProps, hasAdmin }),
          exact: true
        }
      ),
      /* @__PURE__ */ jsx(PrivateRoute, { path: "/usecase", component: UseCasePage }),
      /* @__PURE__ */ jsx(PrivateRoute, { path: "/", component: AuthenticatedApp }),
      /* @__PURE__ */ jsx(Route, { path: "", component: NotFoundPage })
    ] }) })
  ] });
};
const StrapiLogo = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjgwMCIgdmlld0JveD0iMCAwIDgwMCA4MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8cGF0aCBkPSJNMzkgMjgyYzAtMTE4IDAtMTc2LjkgMzYuNi0yMTMuNUMxMTIuMiAzMiAxNzEuMSAzMiAyODguOSAzMmgyMjEuMmMxMTcuOCAwIDE3Ni43IDAgMjEzLjMgMzYuNkM3NjAgMTA1LjIgNzYwIDE2NC4xIDc2MCAyODEuOXYyMjEuMmMwIDExNy44IDAgMTc2LjctMzYuNiAyMTMuM0M2ODYuOCA3NTMgNjI3LjkgNzUzIDUxMC4xIDc1M0gyODguOWMtMTE3LjggMC0xNzYuNyAwLTIxMy4zLTM2LjZDMzkgNjc5LjggMzkgNjIwLjkgMzkgNTAzLjFWMjgxLjlaIiBmaWxsPSIjNDk0NUZGIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTUzNi40IDI1MC43SDI5My43djEyMy44aDEyMy44djEyMy43aDEyMy44VjI1NS41YzAtMi42LTIuMi00LjgtNC45LTQuOFoiIGZpbGw9IiNmZmYiLz4KICAgIDxwYXRoIGZpbGw9IiNmZmYiIGQ9Ik00MTIuNyAzNzQuNWg0Ljh2NC44aC00Ljh6Ii8+CiAgICA8cGF0aCBkPSJNMjkzLjggMzc0LjVoMTE5YzIuNiAwIDQuOCAyLjEgNC44IDQuOHYxMTloLTExOWE0LjggNC44IDAgMCAxLTQuOC00Ljl2LTExOVoiIGZpbGw9IiM5NTkzRkYiLz4KICAgIDxwYXRoIGQ9Ik00MTcuNSA0OTguMmgxMjMuOEw0MjEuNiA2MThhMi40IDIuNCAwIDAgMS00LTEuN3YtMTE4Wk0yOTMuOCAzNzQuNWgtMTE4YTIuNCAyLjQgMCAwIDEtMS43LTQuMWwxMTkuNy0xMTkuN3YxMjMuOFoiIGZpbGw9IiM5NTkzRkYiLz4KPC9zdmc+Cg==";
const [AdminContextProvider, useAdminContext] = createContext("AdminContext");
const useAdmin = () => useAdminContext("useAdmin");
const ConfigurationProvider = ({
  children,
  authLogo: defaultAuthLogo,
  menuLogo: defaultMenuLogo,
  showReleaseNotification = false,
  showTutorials = false
}) => {
  const [{ menuLogo, authLogo }, setLogos] = React.useState({
    menuLogo: null,
    authLogo: null
  });
  const updateProjectSettings = React.useCallback(
    ({ menuLogo: menuLogo2, authLogo: authLogo2 }) => {
      setLogos({
        menuLogo: menuLogo2 || defaultMenuLogo,
        authLogo: authLogo2 || defaultAuthLogo
      });
    },
    [defaultAuthLogo, defaultMenuLogo]
  );
  return /* @__PURE__ */ jsx(
    ConfigurationContextProvider,
    {
      updateProjectSettings,
      showReleaseNotification,
      showTutorials,
      logos: {
        menu: { custom: menuLogo, default: defaultMenuLogo },
        auth: { custom: authLogo, default: defaultAuthLogo }
      },
      children
    }
  );
};
const GuidedTourProvider = ({ children }) => {
  const [{ currentStep, guidedTourState, isGuidedTourVisible, isSkipped }, dispatch] = React.useReducer(reducer$1, initialState$6, initialiseState);
  const setCurrentStep = (step) => {
    if (step !== null) {
      const isStepAlreadyDone = get(guidedTourState, step);
      const [sectionName, stepName] = step.split(".");
      const sectionArray = Object.entries(guidedTourState[sectionName]);
      const currentStepIndex = sectionArray.findIndex(([key]) => key === stepName);
      const previousSteps = sectionArray.slice(0, currentStepIndex);
      const isStepToShow = previousSteps.every(([, sectionValue]) => sectionValue);
      if (isStepAlreadyDone || isSkipped || !isStepToShow) {
        return null;
      }
    }
    auth.set(null, "GUIDED_TOUR_CURRENT_STEP", true);
    return dispatch({
      type: "SET_CURRENT_STEP",
      step
    });
  };
  const setGuidedTourVisibility = (value) => {
    dispatch({
      type: "SET_GUIDED_TOUR_VISIBILITY",
      value
    });
  };
  const setStepState = (currentStep2, value) => {
    addCompletedStep(currentStep2);
    dispatch({
      type: "SET_STEP_STATE",
      currentStep: currentStep2,
      value
    });
  };
  const startSection = (sectionName) => {
    const sectionSteps = guidedTourState[sectionName];
    if (sectionSteps) {
      const guidedTourArray = Object.entries(guidedTourState);
      const currentSectionIndex = guidedTourArray.findIndex(([key]) => key === sectionName);
      const previousSections = guidedTourArray.slice(0, currentSectionIndex);
      const isSectionToShow = previousSections.every(
        ([, sectionValue]) => Object.values(sectionValue).every(Boolean)
      );
      const [firstStep] = Object.keys(sectionSteps);
      const isFirstStepDone = sectionSteps[firstStep];
      if (isSectionToShow && !currentStep && !isFirstStepDone) {
        setCurrentStep(`${sectionName}.${firstStep}`);
      }
    }
  };
  const setSkipped = (value) => {
    auth.set(value, "GUIDED_TOUR_SKIPPED", true);
    dispatch({
      type: "SET_SKIPPED",
      value
    });
  };
  return /* @__PURE__ */ jsx(
    GuidedTourProvider$1,
    {
      guidedTourState,
      currentStep,
      setCurrentStep,
      setGuidedTourVisibility,
      setSkipped,
      setStepState,
      startSection,
      isGuidedTourVisible,
      isSkipped,
      children
    }
  );
};
const initialState$6 = {
  currentStep: null,
  guidedTourState: {
    contentTypeBuilder: {
      create: false,
      success: false
    },
    contentManager: {
      create: false,
      success: false
    },
    apiTokens: {
      create: false,
      success: false
    }
  },
  isGuidedTourVisible: false,
  isSkipped: false
};
const reducer$1 = (state = initialState$6, action) => produce(state, (draftState) => {
  switch (action.type) {
    case "SET_CURRENT_STEP": {
      draftState.currentStep = action.step;
      break;
    }
    case "SET_STEP_STATE": {
      const [section, step] = action.currentStep.split(".");
      draftState.guidedTourState[section][step] = action.value;
      break;
    }
    case "SET_SKIPPED": {
      draftState.isSkipped = action.value;
      break;
    }
    case "SET_GUIDED_TOUR_VISIBILITY": {
      draftState.isGuidedTourVisible = action.value;
      break;
    }
    default: {
      return draftState;
    }
  }
});
const initialiseState = (initialState2) => {
  const copyInitialState = { ...initialState2 };
  const guidedTourLocaleStorage = auth.get("GUIDED_TOUR_COMPLETED_STEPS");
  const currentStepLocaleStorage = auth.get("GUIDED_TOUR_CURRENT_STEP");
  const skippedLocaleStorage = auth.get("GUIDED_TOUR_SKIPPED");
  if (Array.isArray(guidedTourLocaleStorage)) {
    guidedTourLocaleStorage.forEach((step) => {
      const [sectionName, stepName] = step.split(".");
      set(copyInitialState, ["guidedTourState", sectionName, stepName], true);
    });
  }
  if (currentStepLocaleStorage) {
    const [sectionName, stepName] = currentStepLocaleStorage.split(".");
    set(copyInitialState, ["guidedTourState", sectionName, stepName], true);
    addCompletedStep(currentStepLocaleStorage);
    auth.set(null, "GUIDED_TOUR_CURRENT_STEP", true);
  }
  if (skippedLocaleStorage !== null) {
    set(copyInitialState, "isSkipped", skippedLocaleStorage);
  }
  return copyInitialState;
};
const addCompletedStep = (completedStep) => {
  const currentSteps = auth.get("GUIDED_TOUR_COMPLETED_STEPS") ?? [];
  if (!Array.isArray(currentSteps)) {
    return;
  }
  const isAlreadyStored = currentSteps.includes(completedStep);
  if (isAlreadyStored) {
    return;
  }
  auth.set([...currentSteps, completedStep], "GUIDED_TOUR_COMPLETED_STEPS", true);
};
const [ThemeToggleContextProvider, useThemeToggleContext] = createContext("ThemeToggleContext");
const useThemeToggle = () => useThemeToggleContext("useThemeToggle");
const Theme = ({ children }) => {
  const { currentTheme, themes, systemTheme } = useThemeToggle();
  const { locale } = useIntl();
  const computedThemeName = currentTheme === "system" ? systemTheme : currentTheme;
  return /* @__PURE__ */ jsxs(
    DesignSystemProvider,
    {
      locale,
      theme: themes?.[computedThemeName || "light"],
      children: [
        children,
        /* @__PURE__ */ jsx(GlobalStyle, {})
      ]
    }
  );
};
const GlobalStyle = createGlobalStyle`
  body {
    background: ${({ theme }) => theme.colors.neutral100};
  }
`;
const THEME_KEY = "STRAPI_THEME";
const getDefaultTheme = () => {
  const persistedTheme = localStorage.getItem(THEME_KEY);
  return persistedTheme || "system";
};
const ThemeToggleProvider = ({ children, themes }) => {
  const [currentTheme, setCurrentTheme] = React.useState(getDefaultTheme());
  const [systemTheme, setSystemTheme] = React.useState();
  const handleChangeTheme = React.useCallback(
    (nextTheme) => {
      setCurrentTheme(nextTheme);
      localStorage.setItem(THEME_KEY, nextTheme);
    },
    [setCurrentTheme]
  );
  React.useEffect(() => {
    const themeWatcher = window.matchMedia("(prefers-color-scheme: dark)");
    setSystemTheme(themeWatcher.matches ? "dark" : "light");
    const listener = (event) => {
      setSystemTheme(event.matches ? "dark" : "light");
    };
    themeWatcher.addEventListener("change", listener);
    return () => {
      themeWatcher.removeEventListener("change", listener);
    };
  }, []);
  return /* @__PURE__ */ jsx(
    ThemeToggleContextProvider,
    {
      currentTheme,
      onChangeTheme: handleChangeTheme,
      themes,
      systemTheme,
      children
    }
  );
};
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false
    }
  }
});
const Providers = ({
  authLogo,
  children,
  components,
  customFields,
  fields,
  getAdminInjectedComponents,
  getPlugin,
  localeNames,
  menu,
  menuLogo,
  messages,
  plugins,
  runHookParallel,
  runHookSeries,
  runHookWaterfall,
  settings,
  showReleaseNotification,
  showTutorials,
  store,
  themes
}) => {
  return /* @__PURE__ */ jsx(LanguageProvider, { messages, localeNames, children: /* @__PURE__ */ jsx(ThemeToggleProvider, { themes, children: /* @__PURE__ */ jsx(Theme, { children: /* @__PURE__ */ jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsx(Provider, { store, children: /* @__PURE__ */ jsx(AdminContextProvider, { getAdminInjectedComponents, children: /* @__PURE__ */ jsx(
    ConfigurationProvider,
    {
      authLogo,
      menuLogo,
      showReleaseNotification,
      showTutorials,
      children: /* @__PURE__ */ jsx(
        StrapiAppProvider,
        {
          getPlugin,
          menu,
          plugins,
          runHookParallel,
          runHookWaterfall,
          runHookSeries,
          settings,
          children: /* @__PURE__ */ jsx(LibraryProvider, { components, fields, children: /* @__PURE__ */ jsx(CustomFieldsProvider, { customFields, children: /* @__PURE__ */ jsx(AutoReloadOverlayBlockerProvider, { children: /* @__PURE__ */ jsx(OverlayBlockerProvider, { children: /* @__PURE__ */ jsx(GuidedTourProvider, { children: /* @__PURE__ */ jsx(NotificationsProvider, { children }) }) }) }) }) })
        }
      )
    }
  ) }) }) }) }) }) });
};
class Components {
  components;
  constructor() {
    this.components = {};
  }
  add(component) {
    const { name, Component } = component;
    invariant(Component, "A Component must be provided");
    invariant(name, "A name must be provided");
    invariant(this.components[name] === void 0, "A similar field already exists");
    this.components[name] = Component;
  }
}
const ALLOWED_TYPES = [
  "biginteger",
  "boolean",
  "date",
  "datetime",
  "decimal",
  "email",
  "enumeration",
  "float",
  "integer",
  "json",
  "password",
  "richtext",
  "string",
  "text",
  "time",
  "uid"
];
const ALLOWED_ROOT_LEVEL_OPTIONS = [
  "min",
  "minLength",
  "max",
  "maxLength",
  "required",
  "regex",
  "enum",
  "unique",
  "private",
  "default"
];
class CustomFields {
  customFields;
  constructor() {
    this.customFields = {};
  }
  register(customFields) {
    if (Array.isArray(customFields)) {
      customFields.forEach((customField) => {
        this.register(customField);
      });
    } else {
      const { name, pluginId, type, intlLabel, intlDescription, components, options: options2 } = customFields;
      invariant(name, "A name must be provided");
      invariant(type, "A type must be provided");
      invariant(intlLabel, "An intlLabel must be provided");
      invariant(intlDescription, "An intlDescription must be provided");
      invariant(components, "A components object must be provided");
      invariant(components.Input, "An Input component must be provided");
      invariant(
        ALLOWED_TYPES.includes(type),
        `Custom field type: '${type}' is not a valid Strapi type or it can't be used with a Custom Field`
      );
      const isValidObjectKey = /^(?![0-9])[a-zA-Z0-9$_-]+$/g;
      invariant(
        isValidObjectKey.test(name),
        `Custom field name: '${name}' is not a valid object key`
      );
      const allFormOptions = [...options2?.base || [], ...options2?.advanced || []];
      if (allFormOptions.length) {
        const optionPathValidations = allFormOptions.reduce(optionsValidationReducer, []);
        optionPathValidations.forEach(({ isValidOptionPath, errorMessage }) => {
          invariant(isValidOptionPath, errorMessage);
        });
      }
      const uid = pluginId ? `plugin::${pluginId}.${name}` : `global::${name}`;
      const uidAlreadyUsed = Object.prototype.hasOwnProperty.call(this.customFields, uid);
      invariant(!uidAlreadyUsed, `Custom field: '${uid}' has already been registered`);
      this.customFields[uid] = customFields;
    }
  }
  getAll() {
    return this.customFields;
  }
  get(uid) {
    return this.customFields[uid];
  }
}
const optionsValidationReducer = (acc, option) => {
  if ("items" in option) {
    return option.items.reduce(optionsValidationReducer, acc);
  }
  if (!option.name) {
    acc.push({
      isValidOptionPath: false,
      errorMessage: "The 'name' property is required on an options object"
    });
  } else {
    acc.push({
      isValidOptionPath: option.name.startsWith("options") || ALLOWED_ROOT_LEVEL_OPTIONS.includes(option.name),
      errorMessage: `'${option.name}' must be prefixed with 'options.'`
    });
  }
  return acc;
};
class Fields {
  fields;
  constructor() {
    this.fields = {};
  }
  add(field) {
    const { type, Component } = field;
    invariant(Component, "A Component must be provided");
    invariant(type, "A type must be provided");
    this.fields[type] = Component;
  }
}
class Middlewares {
  middlewares;
  constructor() {
    this.middlewares = [];
  }
  add(middleware) {
    this.middlewares.push(middleware);
  }
}
class Plugin {
  apis;
  initializer;
  injectionZones;
  isReady;
  name;
  pluginId;
  constructor(pluginConf) {
    this.apis = pluginConf.apis || {};
    this.initializer = pluginConf.initializer || null;
    this.injectionZones = pluginConf.injectionZones || {};
    this.isReady = pluginConf.isReady !== void 0 ? pluginConf.isReady : true;
    this.name = pluginConf.name;
    this.pluginId = pluginConf.id;
  }
  getInjectedComponents(containerName, blockName) {
    try {
      return this.injectionZones[containerName][blockName] || [];
    } catch (err) {
      console.error("Cannot get injected component", err);
      return [];
    }
  }
  injectComponent(containerName, blockName, component) {
    try {
      this.injectionZones[containerName][blockName].push(component);
    } catch (err) {
      console.error("Cannot inject component", err);
    }
  }
}
class Reducers {
  reducers;
  constructor({ appReducers = {} } = {}) {
    this.reducers = { ...appReducers };
  }
  add(reducerName, reducer2) {
    this.reducers[reducerName] = reducer2;
  }
}
const useTypedDispatch = useDispatch;
const useTypedStore = useStore;
const useTypedSelector = useSelector;
const createTypedSelector = (selector) => createSelector((state) => state, selector);
const RBACProvider = ({ children, permissions, refetchPermissions }) => {
  const allPermissions = useTypedSelector((state) => state.rbacProvider.allPermissions);
  const dispatch = useTypedDispatch();
  React.useEffect(() => {
    dispatch(setPermissionsAction(permissions));
    return () => {
      dispatch(resetStoreAction());
    };
  }, [permissions, dispatch]);
  if (!allPermissions) {
    return /* @__PURE__ */ jsx(LoadingIndicatorPage, {});
  }
  return /* @__PURE__ */ jsx(RBACContext.Provider, { value: { allPermissions, refetchPermissions }, children });
};
const initialState$5 = {
  allPermissions: null,
  collectionTypesRelatedPermissions: {}
};
const RESET_STORE = "StrapiAdmin/RBACProvider/RESET_STORE";
const SET_PERMISSIONS$1 = "StrapiAdmin/RBACProvider/SET_PERMISSIONS";
const resetStoreAction = () => ({ type: RESET_STORE });
const setPermissionsAction = (permissions) => ({
  type: SET_PERMISSIONS$1,
  permissions
});
const RBACReducer = (state = initialState$5, action) => produce(state, (draftState) => {
  switch (action.type) {
    case SET_PERMISSIONS$1: {
      draftState.allPermissions = action.permissions;
      draftState.collectionTypesRelatedPermissions = action.permissions.filter((perm) => perm.subject).reduce((acc, current) => {
        const { subject, action: action2 } = current;
        if (!subject)
          return acc;
        if (!acc[subject]) {
          acc[subject] = {};
        }
        acc[subject] = acc[subject][action2] ? { ...acc[subject], [action2]: [...acc[subject][action2], current] } : { ...acc[subject], [action2]: [current] };
        return acc;
      }, {});
      break;
    }
    case RESET_STORE: {
      return initialState$5;
    }
    default:
      return state;
  }
});
const SET_PERMISSIONS = "ContentManager/RBACManager/SET_PERMISSIONS";
const RESET_PERMISSIONS = "ContentManager/RBACManager/RESET_PERMISSIONS";
const initialState$4 = {
  permissions: null
};
const rbacManagerReducer = (state = initialState$4, action) => (
  // eslint-disable-next-line consistent-return
  produce(state, (draftState) => {
    switch (action.type) {
      case SET_PERMISSIONS: {
        draftState.permissions = Object.entries(action.permissions).reduce((acc, current) => {
          return [...acc, ...current[1]];
        }, []);
        break;
      }
      case RESET_PERMISSIONS: {
        draftState.permissions = null;
        break;
      }
      default:
        return draftState;
    }
  })
);
const GET_INIT_DATA = "ContentManager/App/GET_INIT_DATA";
const RESET_INIT_DATA = "ContentManager/App/RESET_INIT_DATA";
const SET_INIT_DATA = "ContentManager/App/SET_INIT_DATA";
const initialState$3 = {
  components: [],
  status: "loading",
  models: [],
  collectionTypeLinks: [],
  singleTypeLinks: []
};
const mainReducer = (state = initialState$3, action) => produce(state, (draftState) => {
  switch (action.type) {
    case GET_INIT_DATA: {
      draftState.status = "loading";
      break;
    }
    case RESET_INIT_DATA: {
      return initialState$3;
    }
    case SET_INIT_DATA: {
      draftState.collectionTypeLinks = action.data.authorizedCollectionTypeLinks.filter(
        ({ isDisplayed }) => isDisplayed
      );
      draftState.singleTypeLinks = action.data.authorizedSingleTypeLinks.filter(
        ({ isDisplayed }) => isDisplayed
      );
      draftState.components = action.data.components;
      draftState.models = action.data.contentTypeSchemas;
      draftState.fieldSizes = action.data.fieldSizes;
      draftState.status = "resolved";
      break;
    }
    default:
      return draftState;
  }
});
const SET_LAYOUT = "ContentManager/EditViewLayoutManager/SET_LAYOUT";
const RESET_PROPS$2 = "ContentManager/EditViewLayoutManager/RESET_PROPS";
const initialState$2 = {
  currentLayout: null
};
const editViewManagerReducer = (state = initialState$2, action) => (
  // eslint-disable-next-line consistent-return
  produce(state, (draftState) => {
    switch (action.type) {
      case RESET_PROPS$2: {
        draftState.currentLayout = null;
        break;
      }
      case SET_LAYOUT: {
        draftState.currentLayout = action.layout;
        break;
      }
      default:
        return draftState;
    }
  })
);
const GET_DATA$1 = "ContentManager/ListView/GET_DATA";
const GET_DATA_SUCCEEDED$1 = "ContentManager/ListView/GET_DATA_SUCCEEDED";
const RESET_PROPS$1 = "ContentManager/ListView/RESET_PROPS";
const ON_CHANGE_LIST_HEADERS = "ContentManager/ListView/ON_CHANGE_LIST_HEADERS ";
const ON_RESET_LIST_HEADERS = "ContentManager/ListView/ON_RESET_LIST_HEADERS ";
const SET_LIST_LAYOUT = "ContentManager/ListView/SET_LIST_LAYOUT ";
const initialState$1 = {
  data: [],
  isLoading: true,
  contentType: {},
  components: [],
  initialDisplayedHeaders: [],
  displayedHeaders: [],
  pagination: {
    total: 0
  }
};
const listViewReducer = (state = initialState$1, action) => (
  // eslint-disable-next-line consistent-return
  produce(state, (draftState) => {
    switch (action.type) {
      case GET_DATA$1: {
        return {
          ...initialState$1,
          contentType: state.contentType,
          components: state.components,
          initialDisplayedHeaders: state.initialDisplayedHeaders,
          displayedHeaders: state.displayedHeaders
        };
      }
      case GET_DATA_SUCCEEDED$1: {
        draftState.pagination = action.pagination;
        draftState.data = action.data;
        draftState.isLoading = false;
        break;
      }
      case ON_CHANGE_LIST_HEADERS: {
        const {
          target: { name, value }
        } = action;
        if (!value) {
          const { metadatas, attributes, uid } = state.contentType;
          const metas = metadatas[name].list;
          const header = {
            name,
            fieldSchema: attributes[name],
            metadatas: metas,
            key: `__${name}_key__`
          };
          switch (attributes[name].type) {
            case "component": {
              const componentName = attributes[name].component;
              const mainFieldName = get(
                state,
                ["components", componentName, "settings", "mainField"],
                null
              );
              const mainFieldAttribute = get(state, [
                "components",
                componentName,
                "attributes",
                mainFieldName
              ]);
              draftState.displayedHeaders.push({
                ...header,
                metadatas: {
                  ...metas,
                  mainField: {
                    ...mainFieldAttribute,
                    name: mainFieldName
                  }
                }
              });
              break;
            }
            case "relation":
              draftState.displayedHeaders.push({
                ...header,
                queryInfos: {
                  defaultParams: {},
                  endPoint: `collection-types/${uid}`
                }
              });
              break;
            default:
              draftState.displayedHeaders.push(header);
          }
        } else {
          draftState.displayedHeaders = state.displayedHeaders.filter(
            (header) => header.name !== name
          );
        }
        break;
      }
      case ON_RESET_LIST_HEADERS: {
        draftState.displayedHeaders = state.initialDisplayedHeaders;
        break;
      }
      case RESET_PROPS$1: {
        return initialState$1;
      }
      case SET_LIST_LAYOUT: {
        const { contentType, components, displayedHeaders } = action;
        draftState.contentType = contentType;
        draftState.components = components;
        draftState.displayedHeaders = displayedHeaders;
        draftState.initialDisplayedHeaders = displayedHeaders;
        break;
      }
      default:
        return draftState;
    }
  })
);
const GET_DATA = "ContentManager/CrudReducer/GET_DATA";
const GET_DATA_SUCCEEDED = "ContentManager/CrudReducer/GET_DATA_SUCCEEDED";
const INIT_FORM = "ContentManager/CrudReducer/INIT_FORM";
const RESET_PROPS = "ContentManager/CrudReducer/RESET_PROPS";
const SET_DATA_STRUCTURES = "ContentManager/CrudReducer/SET_DATA_STRUCTURES";
const SET_STATUS = "ContentManager/CrudReducer/SET_STATUS";
const SUBMIT_SUCCEEDED = "ContentManager/CrudReducer/SUBMIT_SUCCEEDED";
const CLEAR_SET_MODIFIED_DATA_ONLY = "ContentManager/CrudReducer/CLEAR_SET_MODIFIED_DATA_ONLY";
const crudInitialState = {
  componentsDataStructure: {},
  contentTypeDataStructure: {},
  isLoading: true,
  data: null,
  status: "resolved",
  setModifiedDataOnly: false
};
const crudReducer = (state = crudInitialState, action) => produce(state, (draftState) => {
  switch (action.type) {
    case GET_DATA: {
      draftState.isLoading = true;
      draftState.data = null;
      break;
    }
    case GET_DATA_SUCCEEDED: {
      draftState.isLoading = false;
      draftState.data = action.data;
      draftState.setModifiedDataOnly = action.setModifiedDataOnly ?? false;
      break;
    }
    case INIT_FORM: {
      if (action.data) {
        draftState.isLoading = false;
        draftState.data = action.data;
        break;
      }
      draftState.isLoading = false;
      draftState.data = state.contentTypeDataStructure;
      break;
    }
    case RESET_PROPS: {
      return crudInitialState;
    }
    case SET_DATA_STRUCTURES: {
      draftState.componentsDataStructure = action.componentsDataStructure;
      draftState.contentTypeDataStructure = action.contentTypeDataStructure;
      break;
    }
    case SET_STATUS: {
      draftState.status = action.status;
      break;
    }
    case SUBMIT_SUCCEEDED: {
      draftState.data = action.data;
      break;
    }
    case CLEAR_SET_MODIFIED_DATA_ONLY: {
      draftState.setModifiedDataOnly = false;
      break;
    }
    default:
      return draftState;
  }
});
const initialState = {
  permissions: {},
  status: "init"
};
const reducer = (state = initialState, action) => (
  /* eslint-disable-next-line consistent-return */
  produce(state, (draftState) => {
    switch (action.type) {
      case ACTION_SET_APP_RUNTIME_STATUS: {
        draftState.status = "runtime";
        break;
      }
      case ACTION_SET_ADMIN_PERMISSIONS: {
        draftState.permissions = action.payload;
        break;
      }
      default:
        return draftState;
    }
  })
);
const staticReducers = {
  admin_app: reducer,
  rbacProvider: RBACReducer,
  "content-manager_app": mainReducer,
  "content-manager_listView": listViewReducer,
  "content-manager_rbacManager": rbacManagerReducer,
  "content-manager_editViewLayoutManager": editViewManagerReducer,
  "content-manager_editViewCrudReducer": crudReducer
};
const injectReducerStoreEnhancer = (appReducers) => (next) => (...args) => {
  const store = next(...args);
  const asyncReducers = {};
  return {
    ...store,
    asyncReducers,
    injectReducer: (key, asyncReducer) => {
      asyncReducers[key] = asyncReducer;
      store.replaceReducer(
        // @ts-expect-error we dynamically add reducers which makes the types uncomfortable.
        combineReducers({
          ...appReducers,
          ...asyncReducers
        })
      );
    }
  };
};
const configureStoreImpl = (appMiddlewares = [], injectedReducers = {}) => {
  const coreReducers = { ...staticReducers, ...injectedReducers };
  const store = configureStore({
    reducer: coreReducers,
    devTools: process.env.NODE_ENV !== "production",
    middleware: (getDefaultMiddleware) => [
      ...getDefaultMiddleware(),
      ...appMiddlewares.map((m) => m())
    ],
    enhancers: [injectReducerStoreEnhancer(coreReducers)]
  });
  return store;
};
const getBasename = () => (process.env.ADMIN_PATH ?? "").replace(window.location.origin, "");
const createHook = () => {
  const _handlers = [];
  return {
    register(fn) {
      _handlers.push(fn);
    },
    delete(handler) {
      _handlers.splice(_handlers.indexOf(handler), 1);
    },
    runWaterfall(args, store) {
      return _handlers.reduce((acc, fn) => fn(acc, store), args);
    },
    async runWaterfallAsync(args, store) {
      let result = args;
      for (const fn of _handlers) {
        result = await fn(result, store);
      }
      return result;
    },
    runSeries(...args) {
      return _handlers.map((fn) => fn(...args));
    },
    async runSeriesAsync(...args) {
      const result = [];
      for (const fn of _handlers) {
        result.push(await fn(...args));
      }
      return result;
    },
    runParallel(...args) {
      return Promise.all(
        _handlers.map((fn) => {
          return fn(...args);
        })
      );
    }
  };
};
const useInjectionZone = (area) => {
  const { getAdminInjectedComponents } = useAdmin();
  const [moduleName, page, position] = area.split(".");
  return getAdminInjectedComponents(moduleName, page, position);
};
const INJECTION_ZONES = {
  admin: {
    // Temporary injection zone, support for the react-tour plugin in foodadvisor
    tutorials: {
      links: []
    }
  },
  contentManager: {
    editView: { informations: [], "right-links": [] },
    listView: {
      actions: [],
      deleteModalAdditionalInfos: [],
      publishModalAdditionalInfos: [],
      unpublishModalAdditionalInfos: []
    }
  }
};
const InjectionZone = ({ area, ...props }) => {
  const components = useInjectionZone(area);
  return components.map((component) => /* @__PURE__ */ jsx(component.Component, { ...props }, component.name));
};
const languageNativeNames = {
  ar: "العربية",
  ca: "Català",
  cs: "Čeština",
  de: "Deutsch",
  dk: "Dansk",
  en: "English",
  es: "Español",
  eu: "Euskara",
  fr: "Français",
  gu: "Gujarati",
  he: "עברית",
  hu: "Magyar",
  id: "Indonesian",
  it: "Italiano",
  ja: "日本語",
  ko: "한국어",
  ml: "Malayalam",
  ms: "Melayu",
  nl: "Nederlands",
  no: "Norwegian",
  pl: "Polski",
  "pt-BR": "Português (Brasil)",
  pt: "Português (Portugal)",
  ru: "Русский",
  sk: "Slovenčina",
  sv: "Swedish",
  th: "ไทย",
  tr: "Türkçe",
  uk: "Українська",
  vi: "Tiếng Việt",
  "zh-Hans": "中文 (简体)",
  zh: "中文 (繁體)",
  sa: "संस्कृत",
  hi: "हिन्दी"
};
const {
  INJECT_COLUMN_IN_TABLE,
  MUTATE_COLLECTION_TYPES_LINKS,
  MUTATE_EDIT_VIEW_LAYOUT,
  MUTATE_SINGLE_TYPES_LINKS
} = HOOKS;
class StrapiApp {
  admin;
  appPlugins;
  configurations;
  customBootstrapConfiguration;
  customConfigurations;
  customFields;
  hooksDict;
  library;
  menu;
  middlewares;
  plugins;
  reducers;
  settings;
  translations;
  constructor({ adminConfig, appPlugins } = {}) {
    this.customConfigurations = adminConfig?.config ?? {};
    this.customBootstrapConfiguration = adminConfig?.bootstrap;
    this.configurations = {
      authLogo: StrapiLogo,
      head: { favicon: "" },
      locales: ["en"],
      menuLogo: StrapiLogo,
      notifications: { releases: true },
      themes: { light: lightTheme, dark: darkTheme },
      translations: {},
      tutorials: true
    };
    this.appPlugins = appPlugins || {};
    this.library = {
      components: new Components(),
      fields: new Fields()
    };
    this.middlewares = new Middlewares();
    this.plugins = {};
    this.reducers = new Reducers();
    this.translations = {};
    this.hooksDict = {};
    this.admin = {
      injectionZones: INJECTION_ZONES
    };
    this.customFields = new CustomFields();
    this.menu = [];
    this.settings = {
      global: {
        id: "global",
        intlLabel: {
          id: "Settings.global",
          defaultMessage: "Global Settings"
        },
        links: []
      }
    };
  }
  addComponents = (components) => {
    if (Array.isArray(components)) {
      components.map((compo) => this.library.components.add(compo));
    } else {
      this.library.components.add(components);
    }
  };
  addCorePluginMenuLink = (link) => {
    const stringifiedLink = JSON.stringify(link);
    invariant(link.to, `link.to should be defined for ${stringifiedLink}`);
    invariant(
      typeof link.to === "string",
      `Expected link.to to be a string instead received ${typeof link.to}`
    );
    invariant(
      ["/plugins/content-type-builder", "/plugins/upload"].includes(link.to),
      "This method is not available for your plugin"
    );
    invariant(
      link.intlLabel?.id && link.intlLabel?.defaultMessage,
      `link.intlLabel.id & link.intlLabel.defaultMessage for ${stringifiedLink}`
    );
    this.menu.push(link);
  };
  addFields = (fields) => {
    if (Array.isArray(fields)) {
      fields.map((field) => this.library.fields.add(field));
    } else {
      this.library.fields.add(fields);
    }
  };
  addMenuLink = (link) => {
    const stringifiedLink = JSON.stringify(link);
    invariant(link.to, `link.to should be defined for ${stringifiedLink}`);
    invariant(
      typeof link.to === "string",
      `Expected link.to to be a string instead received ${typeof link.to}`
    );
    invariant(
      link.intlLabel?.id && link.intlLabel?.defaultMessage,
      `link.intlLabel.id & link.intlLabel.defaultMessage for ${stringifiedLink}`
    );
    invariant(
      link.Component && typeof link.Component === "function",
      `link.Component should be a valid React Component`
    );
    invariant(
      link.icon && typeof link.icon === "function",
      `link.Icon should be a valid React Component`
    );
    this.menu.push(link);
  };
  addMiddlewares = (middlewares) => {
    middlewares.forEach((middleware) => {
      this.middlewares.add(middleware);
    });
  };
  addReducers = (reducers) => {
    Object.keys(reducers).forEach((reducerName) => {
      this.reducers.add(reducerName, reducers[reducerName]);
    });
  };
  addSettingsLink = (sectionId, link) => {
    invariant(this.settings[sectionId], "The section does not exist");
    const stringifiedLink = JSON.stringify(link);
    invariant(link.id, `link.id should be defined for ${stringifiedLink}`);
    invariant(
      link.intlLabel?.id && link.intlLabel?.defaultMessage,
      `link.intlLabel.id & link.intlLabel.defaultMessage for ${stringifiedLink}`
    );
    invariant(link.to, `link.to should be defined for ${stringifiedLink}`);
    invariant(
      link.Component && typeof link.Component === "function",
      `link.Component should be a valid React Component`
    );
    this.settings[sectionId].links.push(link);
  };
  addSettingsLinks = (sectionId, links) => {
    invariant(this.settings[sectionId], "The section does not exist");
    invariant(Array.isArray(links), "TypeError expected links to be an array");
    links.forEach((link) => {
      this.addSettingsLink(sectionId, link);
    });
  };
  async bootstrap() {
    Object.keys(this.appPlugins).forEach((plugin) => {
      const bootstrap = this.appPlugins[plugin].bootstrap;
      if (bootstrap) {
        bootstrap({
          addSettingsLink: this.addSettingsLink,
          addSettingsLinks: this.addSettingsLinks,
          getPlugin: this.getPlugin,
          injectContentManagerComponent: this.injectContentManagerComponent,
          injectAdminComponent: this.injectAdminComponent,
          registerHook: this.registerHook
        });
      }
    });
    if (isFunction(this.customBootstrapConfiguration)) {
      this.customBootstrapConfiguration({
        addComponents: this.addComponents,
        addFields: this.addFields,
        addMenuLink: this.addMenuLink,
        addReducers: this.addReducers,
        addSettingsLink: this.addSettingsLink,
        addSettingsLinks: this.addSettingsLinks,
        getPlugin: this.getPlugin,
        injectContentManagerComponent: this.injectContentManagerComponent,
        injectAdminComponent: this.injectAdminComponent,
        registerHook: this.registerHook
      });
    }
  }
  bootstrapAdmin = async () => {
    await this.createCustomConfigurations();
    this.createHook(INJECT_COLUMN_IN_TABLE);
    this.createHook(MUTATE_COLLECTION_TYPES_LINKS);
    this.createHook(MUTATE_SINGLE_TYPES_LINKS);
    this.createHook(MUTATE_EDIT_VIEW_LAYOUT);
    return Promise.resolve();
  };
  createCustomConfigurations = async () => {
    if (this.customConfigurations?.locales) {
      this.configurations.locales = [
        "en",
        ...this.customConfigurations.locales?.filter((loc) => loc !== "en") || []
      ];
    }
    if (this.customConfigurations?.auth?.logo) {
      this.configurations.authLogo = this.customConfigurations.auth.logo;
    }
    if (this.customConfigurations?.menu?.logo) {
      this.configurations.menuLogo = this.customConfigurations.menu.logo;
    }
    if (this.customConfigurations?.head?.favicon) {
      this.configurations.head.favicon = this.customConfigurations.head.favicon;
    }
    if (this.customConfigurations?.theme) {
      const darkTheme2 = this.customConfigurations.theme.dark;
      const lightTheme2 = this.customConfigurations.theme.light;
      if (!darkTheme2 && !lightTheme2) {
        console.warn(
          `[deprecated] In future versions, Strapi will stop supporting this theme customization syntax. The theme configuration accepts a light and a dark key to customize each theme separately. See https://docs.strapi.io/developer-docs/latest/development/admin-customization.html#theme-extension.`
        );
        merge(this.configurations.themes.light, this.customConfigurations.theme);
      }
      if (lightTheme2)
        merge(this.configurations.themes.light, lightTheme2);
      if (darkTheme2)
        merge(this.configurations.themes.dark, darkTheme2);
    }
    if (this.customConfigurations?.notifications?.releases !== void 0) {
      this.configurations.notifications.releases = this.customConfigurations.notifications.releases;
    }
    if (this.customConfigurations?.tutorials !== void 0) {
      this.configurations.tutorials = this.customConfigurations.tutorials;
    }
  };
  createHook = (name) => {
    this.hooksDict[name] = createHook();
  };
  createSettingSection = (section, links) => {
    invariant(section.id, "section.id should be defined");
    invariant(
      section.intlLabel?.id && section.intlLabel?.defaultMessage,
      "section.intlLabel should be defined"
    );
    invariant(Array.isArray(links), "TypeError expected links to be an array");
    invariant(this.settings[section.id] === void 0, "A similar section already exists");
    this.settings[section.id] = { ...section, links: [] };
    links.forEach((link) => {
      this.addSettingsLink(section.id, link);
    });
  };
  createStore = () => {
    const store = configureStoreImpl(this.middlewares.middlewares, this.reducers.reducers);
    return store;
  };
  getAdminInjectedComponents = (moduleName, containerName, blockName) => {
    try {
      return this.admin.injectionZones[moduleName][containerName][blockName] || [];
    } catch (err) {
      console.error("Cannot get injected component", err);
      return [];
    }
  };
  getPlugin = (pluginId) => {
    return this.plugins[pluginId];
  };
  async initialize() {
    Object.keys(this.appPlugins).forEach((plugin) => {
      this.appPlugins[plugin].register(this);
    });
  }
  injectContentManagerComponent = (containerName, blockName, component) => {
    invariant(
      this.admin.injectionZones.contentManager[containerName]?.[blockName],
      `The ${containerName} ${String(blockName)} zone is not defined in the content manager`
    );
    invariant(component, "A Component must be provided");
    this.admin.injectionZones.contentManager[containerName][blockName].push(component);
  };
  injectAdminComponent = (containerName, blockName, component) => {
    invariant(
      this.admin.injectionZones.admin[containerName]?.[blockName],
      `The ${containerName} ${String(blockName)} zone is not defined in the admin`
    );
    invariant(component, "A Component must be provided");
    this.admin.injectionZones.admin[containerName][blockName].push(component);
  };
  /**
   * Load the admin translations
   * @returns {Object} The imported admin translations
   */
  async loadAdminTrads() {
    const arrayOfPromises = this.configurations.locales.map((locale) => {
      return __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "./translations/ar.json": () => import("./ar-62e5e2b3.mjs"), "./translations/ca.json": () => import("./ca-e99de225.mjs"), "./translations/cs.json": () => import("./cs-2fa881a2.mjs"), "./translations/de.json": () => import("./de-28f8bc28.mjs"), "./translations/dk.json": () => import("./dk-0b759a56.mjs"), "./translations/en.json": () => import("./en-e728accb.mjs"), "./translations/es.json": () => import("./es-18b29db2.mjs"), "./translations/eu.json": () => import("./eu-8fd773c2.mjs"), "./translations/fr.json": () => import("./fr-f37df086.mjs"), "./translations/gu.json": () => import("./gu-69f0e13a.mjs"), "./translations/he.json": () => import("./he-bd769d7e.mjs"), "./translations/hi.json": () => import("./hi-d397a24b.mjs"), "./translations/hu.json": () => import("./hu-eb88bd0c.mjs"), "./translations/id.json": () => import("./id-f47699e6.mjs"), "./translations/it.json": () => import("./it-4006227c.mjs"), "./translations/ja.json": () => import("./ja-db43ca3d.mjs"), "./translations/ko.json": () => import("./ko-a7826e25.mjs"), "./translations/ml.json": () => import("./ml-90131768.mjs"), "./translations/ms.json": () => import("./ms-f4f16a83.mjs"), "./translations/nl.json": () => import("./nl-887ce2c3.mjs"), "./translations/no.json": () => import("./no-f0b02541.mjs"), "./translations/pl.json": () => import("./pl-9ccd35d9.mjs"), "./translations/pt-BR.json": () => import("./pt-BR-fd73cb13.mjs"), "./translations/pt.json": () => import("./pt-8acb6ac1.mjs"), "./translations/ru.json": () => import("./ru-9aad40c5.mjs"), "./translations/sa.json": () => import("./sa-6bf4c20e.mjs"), "./translations/sk.json": () => import("./sk-58d31b17.mjs"), "./translations/sv.json": () => import("./sv-d80ad633.mjs"), "./translations/th.json": () => import("./th-e72c6a22.mjs"), "./translations/tr.json": () => import("./tr-e35ecfe8.mjs"), "./translations/uk.json": () => import("./uk-de367ec1.mjs"), "./translations/vi.json": () => import("./vi-096bccbb.mjs"), "./translations/zh-Hans.json": () => import("./zh-Hans-ccf4be4b.mjs"), "./translations/zh.json": () => import("./zh-ba29b2e1.mjs") }), `./translations/${locale}.json`).then(({ default: data }) => {
        return { data, locale };
      }).catch(() => {
        return { data: null, locale };
      });
    });
    const adminLocales = await Promise.all(arrayOfPromises);
    const translations = adminLocales.reduce(
      (acc, current) => {
        if (current.data) {
          acc[current.locale] = current.data;
        }
        return acc;
      },
      {}
    );
    return translations;
  }
  /**
   * Load the application's translations and merged the custom translations
   * with the default ones.
   *
   */
  async loadTrads() {
    const adminTranslations = await this.loadAdminTrads();
    const arrayOfPromises = Object.keys(this.appPlugins).map((plugin) => {
      const registerTrads = this.appPlugins[plugin].registerTrads;
      if (registerTrads) {
        return registerTrads({ locales: this.configurations.locales });
      }
      return null;
    }).filter((a) => a);
    const pluginsTrads = await Promise.all(arrayOfPromises);
    const mergedTrads = pluginsTrads.reduce(
      (acc, currentPluginTrads) => {
        const pluginTrads = currentPluginTrads.reduce(
          (acc1, current) => {
            acc1[current.locale] = current.data;
            return acc1;
          },
          {}
        );
        Object.keys(pluginTrads).forEach((locale) => {
          acc[locale] = { ...acc[locale], ...pluginTrads[locale] };
        });
        return acc;
      },
      {}
    );
    const translations = this.configurations.locales.reduce((acc, current) => {
      acc[current] = {
        ...adminTranslations[current],
        ...mergedTrads[current] || {},
        ...this.customConfigurations?.translations?.[current] ?? {}
      };
      return acc;
    }, {});
    this.configurations.translations = translations;
    return Promise.resolve();
  }
  registerHook = (name, fn) => {
    invariant(
      this.hooksDict[name],
      `The hook ${name} is not defined. You are trying to register a hook that does not exist in the application.`
    );
    this.hooksDict[name].register(fn);
  };
  registerPlugin = (pluginConf) => {
    const plugin = new Plugin(pluginConf);
    this.plugins[plugin.pluginId] = plugin;
  };
  runHookSeries = (name, asynchronous = false) => asynchronous ? this.hooksDict[name].runSeriesAsync() : this.hooksDict[name].runSeries();
  runHookWaterfall = (name, initialValue, asynchronous = false, store) => {
    return asynchronous ? this.hooksDict[name].runWaterfallAsync(initialValue, store) : this.hooksDict[name].runWaterfall(initialValue, store);
  };
  runHookParallel = (name) => this.hooksDict[name].runParallel();
  render() {
    const store = this.createStore();
    const localeNames = pick(languageNativeNames, this.configurations.locales || []);
    const {
      components: { components },
      fields: { fields }
    } = this.library;
    return /* @__PURE__ */ jsxs(
      Providers,
      {
        authLogo: this.configurations.authLogo,
        components,
        fields,
        customFields: this.customFields,
        localeNames,
        getAdminInjectedComponents: this.getAdminInjectedComponents,
        getPlugin: this.getPlugin,
        messages: this.configurations.translations,
        menu: this.menu,
        menuLogo: this.configurations.menuLogo,
        plugins: this.plugins,
        runHookParallel: this.runHookParallel,
        runHookWaterfall: (name, initialValue, async = false) => {
          return this.runHookWaterfall(name, initialValue, async, store);
        },
        runHookSeries: this.runHookSeries,
        themes: this.configurations.themes,
        settings: this.settings,
        showTutorials: this.configurations.tutorials,
        showReleaseNotification: this.configurations.notifications.releases,
        store,
        children: [
          /* @__PURE__ */ jsx(
            Helmet,
            {
              htmlAttributes: { lang: localStorage.getItem(LANGUAGE_LOCAL_STORAGE_KEY) || "en" }
            }
          ),
          /* @__PURE__ */ jsx(BrowserRouter, { basename: getBasename(), children: /* @__PURE__ */ jsx(App, {}) })
        ]
      }
    );
  }
}
const renderAdmin = async (mountNode, { plugins, customisations, features }) => {
  if (!mountNode) {
    throw new Error("[@strapi/admin]: Could not find the root element to mount the admin app");
  }
  window.strapi = {
    /**
     * This ENV variable is passed from the strapi instance, by default no url is set
     * in the config and therefore the instance returns you an empty string so URLs are relative.
     *
     * To ensure that the backendURL is always set, we use the window.location.origin as a fallback.
     */
    backendURL: process.env.STRAPI_ADMIN_BACKEND_URL || window.location.origin,
    isEE: false,
    telemetryDisabled: process.env.STRAPI_TELEMETRY_DISABLED === "true" ? true : false,
    future: {
      isEnabled: (name) => {
        return features?.future?.[name] === true;
      }
    },
    // @ts-expect-error – there's pollution from the global scope of Node.
    features: {
      SSO: "sso",
      AUDIT_LOGS: "audit-logs",
      REVIEW_WORKFLOWS: "review-workflows",
      /**
       * If we don't get the license then we know it's not EE
       * so no feature is enabled.
       */
      isEnabled: () => false
    },
    projectType: "Community",
    flags: {
      nps: false,
      promoteEE: true
    }
  };
  const { get: get2 } = getFetchClient();
  try {
    const {
      data: {
        data: { isEE, features: features2, flags }
      }
    } = await get2("/admin/project-type");
    window.strapi.isEE = isEE;
    window.strapi.flags = flags;
    window.strapi.features = {
      ...window.strapi.features,
      isEnabled: (featureName) => features2.some((feature) => feature.name === featureName)
    };
    window.strapi.projectType = isEE ? "Enterprise" : "Community";
  } catch (err) {
    console.error(err);
  }
  const app = new StrapiApp({
    adminConfig: customisations,
    appPlugins: plugins
  });
  await app.bootstrapAdmin();
  await app.initialize();
  await app.bootstrap();
  await app.loadTrads();
  createRoot(mountNode).render(app.render());
  if (typeof module !== "undefined" && module && "hot" in module && typeof module.hot === "object" && module.hot !== null && "accept" in module.hot && typeof module.hot.accept === "function") {
    module.hot.accept();
  }
};
export {
  ACTION_SET_APP_RUNTIME_STATUS as A,
  crudInitialState as B,
  Column as C,
  RESET_INIT_DATA as D,
  GET_INIT_DATA as E,
  SET_INIT_DATA as F,
  GET_DATA as G,
  HOOKS as H,
  INIT_FORM as I,
  initialState$3 as J,
  StrapiLogo as K,
  Login as L,
  useLocales as M,
  NpsSurvey as N,
  ON_RESET_LIST_HEADERS as O,
  useThemeToggle as P,
  SETTINGS_LINKS_CE as Q,
  RBACProvider as R,
  SET_PERMISSIONS as S,
  getBasename as T,
  UnauthenticatedLayout as U,
  useTypedStore as V,
  DefaultDocument as W,
  renderAdmin as X,
  NotFoundPage$1 as Y,
  useTypedDispatch as a,
  useTypedSelector as b,
  createTypedSelector as c,
  createRoute as d,
  LayoutContent as e,
  Logo as f,
  RESET_PERMISSIONS as g,
  RESET_PROPS$2 as h,
  SET_LAYOUT as i,
  RESET_PROPS as j,
  SET_DATA_STRUCTURES as k,
  SET_STATUS as l,
  SUBMIT_SUCCEEDED as m,
  GET_DATA_SUCCEEDED as n,
  CLEAR_SET_MODIFIED_DATA_ONLY as o,
  useEnterprise as p,
  InjectionZone as q,
  GET_DATA$1 as r,
  GET_DATA_SUCCEEDED$1 as s,
  RESET_PROPS$1 as t,
  useConfiguration as u,
  SET_LIST_LAYOUT as v,
  ON_CHANGE_LIST_HEADERS as w,
  useInjectionZone as x,
  initialState$1 as y,
  crudReducer as z
};
//# sourceMappingURL=index-8933483b.mjs.map
