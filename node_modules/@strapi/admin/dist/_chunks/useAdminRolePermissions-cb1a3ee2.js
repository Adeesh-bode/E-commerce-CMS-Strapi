"use strict";
const jsxRuntime = require("react/jsx-runtime");
const React = require("react");
const designSystem = require("@strapi/design-system");
const helperPlugin = require("@strapi/helper-plugin");
const has = require("lodash/has");
const isEmpty = require("lodash/isEmpty");
const PropTypes = require("prop-types");
const reactIntl = require("react-intl");
const reactContext = require("@radix-ui/react-context");
const sortBy = require("lodash/sortBy");
const styled = require("styled-components");
const Icons = require("@strapi/icons");
const get = require("lodash/get");
const omit = require("lodash/omit");
const v2 = require("@strapi/design-system/v2");
const produce = require("immer");
const groupBy = require("lodash/groupBy");
const upperFirst = require("lodash/upperFirst");
const flattenDeep = require("lodash/flattenDeep");
const isObject = require("lodash/isObject");
const merge = require("lodash/merge");
const set = require("lodash/set");
const cloneDeep = require("lodash/cloneDeep");
const reactQuery = require("react-query");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const has__default = /* @__PURE__ */ _interopDefault(has);
const isEmpty__default = /* @__PURE__ */ _interopDefault(isEmpty);
const PropTypes__default = /* @__PURE__ */ _interopDefault(PropTypes);
const sortBy__default = /* @__PURE__ */ _interopDefault(sortBy);
const styled__default = /* @__PURE__ */ _interopDefault(styled);
const get__default = /* @__PURE__ */ _interopDefault(get);
const omit__default = /* @__PURE__ */ _interopDefault(omit);
const produce__default = /* @__PURE__ */ _interopDefault(produce);
const groupBy__default = /* @__PURE__ */ _interopDefault(groupBy);
const upperFirst__default = /* @__PURE__ */ _interopDefault(upperFirst);
const flattenDeep__default = /* @__PURE__ */ _interopDefault(flattenDeep);
const isObject__default = /* @__PURE__ */ _interopDefault(isObject);
const merge__default = /* @__PURE__ */ _interopDefault(merge);
const set__default = /* @__PURE__ */ _interopDefault(set);
const cloneDeep__default = /* @__PURE__ */ _interopDefault(cloneDeep);
const [PermissionsDataManagerProvider, usePermissionsDataManagerContext] = reactContext.createContext("PermissionsDataManager");
const usePermissionsDataManager = () => usePermissionsDataManagerContext("usePermissionsDataManager");
const Wrapper$5 = styled__default.default.div`
  position: relative;

  ${({ hasConditions, disabled, theme }) => hasConditions && `
    &:before {
      content: '';
      position: absolute;
      top: -3px;
      left: -10px;
      width: 6px;
      height: 6px;
      border-radius: ${20 / 16}rem;;
      background: ${disabled ? theme.colors.neutral100 : theme.colors.primary600};
    }
  `}
`;
const ConditionsButton = ({ onClick, className, hasConditions, variant }) => {
  const { formatMessage } = reactIntl.useIntl();
  return /* @__PURE__ */ jsxRuntime.jsx(Wrapper$5, { hasConditions, className, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Button, { variant, startIcon: /* @__PURE__ */ jsxRuntime.jsx(Icons.Cog, {}), onClick, children: formatMessage({
    id: "global.settings",
    defaultMessage: "Settings"
  }) }) });
};
ConditionsButton.defaultProps = {
  className: null,
  hasConditions: false,
  variant: "tertiary"
};
ConditionsButton.propTypes = {
  onClick: PropTypes__default.default.func.isRequired,
  className: PropTypes__default.default.string,
  hasConditions: PropTypes__default.default.bool,
  variant: PropTypes__default.default.string
};
const ConditionsButton$1 = styled__default.default(ConditionsButton)``;
const getSelectedValues = (rawValue) => Object.values(rawValue).map(
  (x) => Object.entries(x).filter(([, value]) => value).map(([key]) => key)
).flat();
const getNestedOptions = (options) => options.reduce((acc, [label, children]) => {
  acc.push({
    label: upperFirst__default.default(label),
    children: children.map((child) => ({
      label: child.displayName,
      value: child.id
    }))
  });
  return acc;
}, []);
const getNewStateFromChangedValues = (options, changedValues) => options.map(([, values]) => values).flat().reduce((acc, curr) => ({ [curr.id]: changedValues.includes(curr.id), ...acc }), {});
const ActionRow$2 = ({
  arrayOfOptionsGroupedByCategory,
  isFormDisabled,
  isGrey,
  label,
  name,
  onChange,
  value
}) => {
  const { formatMessage } = reactIntl.useIntl();
  const handleChange = (val) => {
    onChange(name, getNewStateFromChangedValues(arrayOfOptionsGroupedByCategory, val));
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { as: "li", background: isGrey ? "neutral100" : "neutral0", paddingBottom: 3, paddingTop: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { paddingLeft: 6, style: { width: 180 }, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Typography, { variant: "sigma", textColor: "neutral600", children: [
        formatMessage({
          id: "Settings.permissions.conditions.can",
          defaultMessage: "Can"
        }),
        " "
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "sigma", title: label, textColor: "primary600", ellipsis: true, children: formatMessage({
        id: `Settings.roles.form.permissions.${label.toLowerCase()}`,
        defaultMessage: label
      }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Typography, { variant: "sigma", textColor: "neutral600", children: [
        " ",
        formatMessage({
          id: "Settings.permissions.conditions.when",
          defaultMessage: "When"
        })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { style: { maxWidth: 430, width: "100%" }, children: /* @__PURE__ */ jsxRuntime.jsx(
      designSystem.MultiSelectNested,
      {
        id: name,
        customizeContent: (values) => `${values.length} currently selected`,
        onChange: handleChange,
        value: getSelectedValues(value),
        options: getNestedOptions(arrayOfOptionsGroupedByCategory),
        disabled: isFormDisabled
      }
    ) })
  ] });
};
ActionRow$2.propTypes = {
  arrayOfOptionsGroupedByCategory: PropTypes__default.default.array.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  isGrey: PropTypes__default.default.bool.isRequired,
  label: PropTypes__default.default.string.isRequired,
  name: PropTypes__default.default.string.isRequired,
  value: PropTypes__default.default.object.isRequired,
  onChange: PropTypes__default.default.func.isRequired
};
const createConditionsForm = (conditions, valueObject) => {
  return conditions.reduce((acc, current) => {
    acc[current.id] = get__default.default(valueObject, current.id, false);
    return acc;
  }, {});
};
const createCategoryForm = (arrayOfOptions, valueObject) => {
  return arrayOfOptions.reduce((acc, current) => {
    const [categoryName, relatedConditions] = current;
    const conditionsForm = createConditionsForm(relatedConditions, valueObject);
    acc[categoryName] = conditionsForm;
    return acc;
  }, {});
};
const createDefaultConditionsForm$1 = (actionsToDisplay, modifiedData, arrayOfOptionsGroupedByCategory) => {
  return actionsToDisplay.reduce((acc, current) => {
    const valueFromModifiedData = get__default.default(
      modifiedData,
      [...current.pathToConditionsObject, "conditions"],
      {}
    );
    const categoryDefaultForm = createCategoryForm(
      arrayOfOptionsGroupedByCategory,
      valueFromModifiedData
    );
    acc[current.pathToConditionsObject.join("..")] = categoryDefaultForm;
    return acc;
  }, {});
};
const ConditionsModal = ({ actions, headerBreadCrumbs, isFormDisabled, onClosed, onToggle }) => {
  const { formatMessage } = reactIntl.useIntl();
  const { availableConditions, modifiedData, onChangeConditions } = usePermissionsDataManager();
  const arrayOfOptionsGroupedByCategory = React.useMemo(() => {
    return Object.entries(groupBy__default.default(availableConditions, "category"));
  }, [availableConditions]);
  const actionsToDisplay = actions.filter(
    ({ isDisplayed, hasSomeActionsSelected, hasAllActionsSelected }) => isDisplayed && (hasSomeActionsSelected || hasAllActionsSelected)
  );
  const initState = React.useMemo(() => {
    return createDefaultConditionsForm$1(
      actionsToDisplay,
      modifiedData,
      arrayOfOptionsGroupedByCategory
    );
  }, [actionsToDisplay, modifiedData, arrayOfOptionsGroupedByCategory]);
  const [state, setState] = React.useState(initState);
  const handleChange = (name, values) => {
    setState(
      produce__default.default((draft) => {
        if (!draft[name]) {
          draft[name] = {};
        }
        if (!draft[name].default) {
          draft[name].default = {};
        }
        draft[name].default = values;
      })
    );
  };
  const handleSubmit = () => {
    const conditionsWithoutCategory = Object.entries(state).reduce((acc, current) => {
      const [key, value] = current;
      const merged = Object.values(value).reduce((acc1, current1) => {
        return { ...acc1, ...current1 };
      }, {});
      acc[key] = merged;
      return acc;
    }, {});
    onChangeConditions(conditionsWithoutCategory);
    onToggle();
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(designSystem.ModalLayout, { labelledBy: "condition-modal-breadcrumbs", onClose: onClosed, children: [
    /* @__PURE__ */ jsxRuntime.jsx(designSystem.ModalHeader, { children: /* @__PURE__ */ jsxRuntime.jsx(v2.Breadcrumbs, { id: "condition-modal-breadcrumbs", label: headerBreadCrumbs.join(", "), children: headerBreadCrumbs.map((label, index, arr) => /* @__PURE__ */ jsxRuntime.jsx(v2.Crumb, { isCurrent: index === arr.length - 1, children: upperFirst__default.default(
      formatMessage({
        id: label,
        defaultMessage: label
      })
    ) }, label)) }) }),
    /* @__PURE__ */ jsxRuntime.jsxs(designSystem.ModalBody, { children: [
      actionsToDisplay.length === 0 && /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { children: formatMessage({
        id: "Settings.permissions.conditions.no-actions",
        defaultMessage: "You first need to select actions (create, read, update, ...) before defining conditions on them."
      }) }),
      /* @__PURE__ */ jsxRuntime.jsx("ul", { children: actionsToDisplay.map(({ actionId, label, pathToConditionsObject }, index) => {
        const name = pathToConditionsObject.join("..");
        return /* @__PURE__ */ jsxRuntime.jsx(
          ActionRow$2,
          {
            arrayOfOptionsGroupedByCategory,
            label,
            isFormDisabled,
            isGrey: index % 2 === 0,
            name,
            onChange: handleChange,
            value: get__default.default(state, name, {})
          },
          actionId
        );
      }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      designSystem.ModalFooter,
      {
        startActions: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Button, { variant: "tertiary", onClick: onToggle, children: formatMessage({ id: "app.components.Button.cancel", defaultMessage: "Cancel" }) }),
        endActions: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Button, { onClick: handleSubmit, children: formatMessage({
          id: "Settings.permissions.conditions.apply",
          defaultMessage: "Apply"
        }) })
      }
    )
  ] });
};
ConditionsModal.propTypes = {
  actions: PropTypes__default.default.arrayOf(
    PropTypes__default.default.shape({
      actionId: PropTypes__default.default.string.isRequired,
      checkboxName: PropTypes__default.default.string,
      hasSomeActionsSelected: PropTypes__default.default.bool.isRequired,
      hasAllActionsSelected: PropTypes__default.default.bool,
      isDisplayed: PropTypes__default.default.bool.isRequired,
      label: PropTypes__default.default.string
    })
  ).isRequired,
  headerBreadCrumbs: PropTypes__default.default.arrayOf(PropTypes__default.default.string).isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  onClosed: PropTypes__default.default.func.isRequired,
  onToggle: PropTypes__default.default.func.isRequired
};
const cellWidth = `${120 / 16}rem`;
const firstRowWidth = `${200 / 16}rem`;
const rowHeight = `${53 / 16}rem`;
const HiddenAction = styled__default.default.div`
  width: ${cellWidth};
`;
const CollapseLabel = styled__default.default(designSystem.Flex)`
  padding-right: ${({ theme }) => theme.spaces[2]};
  overflow: hidden;
  flex: 1;
  ${({ isCollapsable }) => isCollapsable && "cursor: pointer;"}
`;
const RowLabelWithCheckbox = ({
  children,
  isCollapsable,
  isActive,
  isFormDisabled,
  label,
  onChange,
  onClick,
  checkboxName,
  someChecked,
  value
}) => {
  const { formatMessage } = reactIntl.useIntl();
  return /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { alignItems: "center", paddingLeft: 6, style: { width: firstRowWidth, flexShrink: 0 }, children: [
    /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { paddingRight: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
      designSystem.BaseCheckbox,
      {
        name: checkboxName,
        "aria-label": formatMessage(
          {
            id: `Settings.permissions.select-all-by-permission`,
            defaultMessage: "Select all {label} permissions"
          },
          { label }
        ),
        disabled: isFormDisabled,
        onValueChange: (value2) => onChange({
          target: {
            name: checkboxName,
            value: value2
          }
        }),
        indeterminate: someChecked,
        value
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsxs(
      CollapseLabel,
      {
        title: label,
        alignItems: "center",
        isCollapsable,
        ...isCollapsable && {
          onClick,
          "aria-expanded": isActive,
          onKeyDown: ({ key }) => (key === "Enter" || key === " ") && onClick(),
          tabIndex: 0,
          role: "button"
        },
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            designSystem.Typography,
            {
              fontWeight: isActive ? "bold" : "",
              textColor: isActive ? "primary600" : "neutral800",
              ellipsis: true,
              children: upperFirst__default.default(label)
            }
          ),
          children
        ]
      }
    )
  ] });
};
RowLabelWithCheckbox.defaultProps = {
  children: null,
  checkboxName: "",
  onChange() {
  },
  value: false,
  someChecked: false,
  isCollapsable: false
};
RowLabelWithCheckbox.propTypes = {
  checkboxName: PropTypes__default.default.string,
  children: PropTypes__default.default.node,
  label: PropTypes__default.default.string.isRequired,
  isCollapsable: PropTypes__default.default.bool,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  onChange: PropTypes__default.default.func,
  onClick: PropTypes__default.default.func.isRequired,
  someChecked: PropTypes__default.default.bool,
  value: PropTypes__default.default.bool,
  isActive: PropTypes__default.default.bool.isRequired
};
const RowLabelWithCheckbox$1 = React.memo(RowLabelWithCheckbox);
const createArrayOfValues = (obj) => {
  if (!isObject__default.default(obj)) {
    return [];
  }
  return flattenDeep__default.default(
    Object.values(obj).map((value) => {
      if (isObject__default.default(value)) {
        return createArrayOfValues(value);
      }
      return value;
    })
  );
};
const removeConditionKeyFromData = (obj) => {
  if (!obj) {
    return null;
  }
  return Object.keys(obj).reduce((acc, current) => {
    if (current !== "conditions") {
      acc[current] = obj[current];
    }
    return acc;
  }, {});
};
const getCheckboxState = (dataObj) => {
  const dataWithoutCondition = removeConditionKeyFromData(dataObj);
  const arrayOfValues = createArrayOfValues(dataWithoutCondition);
  if (!arrayOfValues.length) {
    return { hasAllActionsSelected: false, hasSomeActionsSelected: false };
  }
  const hasAllActionsSelected = arrayOfValues.every((val) => val);
  const hasSomeActionsSelected = arrayOfValues.some((val) => val) && !hasAllActionsSelected;
  return { hasAllActionsSelected, hasSomeActionsSelected };
};
const CarretIcon = styled__default.default(Icons.CarretDown)`
  display: none;
  width: ${10 / 16}rem;
  transform: rotate(${({ $isActive }) => $isActive ? "180" : "0"}deg);
  margin-left: ${({ theme }) => theme.spaces[2]};
`;
const activeStyle = (theme) => `
  ${designSystem.Typography} {
    color: ${theme.colors.primary600};
    font-weight: ${theme.fontWeights.bold}
  }
  ${CarretIcon} {
    display: block;
    path {
      fill: ${theme.colors.primary600}
    };
  }
`;
const generateCheckboxesActions = (availableActions, modifiedData, pathToData) => {
  return availableActions.map(({ actionId, isDisplayed, applyToProperties, label }) => {
    if (!isDisplayed) {
      return { actionId, hasSomeActionsSelected: false, isDisplayed };
    }
    const baseCheckboxNameArray = [...pathToData.split(".."), actionId];
    const checkboxNameArray = isEmpty__default.default(applyToProperties) ? [...baseCheckboxNameArray, "properties", "enabled"] : baseCheckboxNameArray;
    const checkboxName = checkboxNameArray.join("..");
    const conditionsValue = get__default.default(modifiedData, [...baseCheckboxNameArray, "conditions"], null);
    const hasConditions = createArrayOfValues(conditionsValue).some((val) => val);
    if (isEmpty__default.default(applyToProperties)) {
      const value = get__default.default(modifiedData, checkboxNameArray, false);
      return {
        actionId,
        checkboxName,
        hasAllActionsSelected: value,
        hasConditions,
        hasSomeActionsSelected: value,
        isDisplayed,
        isParentCheckbox: false,
        label,
        pathToConditionsObject: baseCheckboxNameArray
      };
    }
    const mainData = get__default.default(modifiedData, checkboxNameArray, null);
    const { hasAllActionsSelected, hasSomeActionsSelected } = getCheckboxState(mainData);
    return {
      actionId,
      checkboxName,
      hasAllActionsSelected,
      hasConditions,
      hasSomeActionsSelected,
      isDisplayed,
      isParentCheckbox: true,
      label,
      pathToConditionsObject: baseCheckboxNameArray
    };
  });
};
const activeRowStyle = (theme, isActive) => `
  ${Wrapper$4} {
    background-color: ${theme.colors.primary100};
    color: ${theme.colors.primary600};
    border-radius: ${isActive ? "2px 2px 0 0" : "2px"};
  }
  ${Chevron} {
    display: flex;
  }
  ${ConditionsButton$1} {
    display: block;
  }
  &:hover {
   ${activeStyle(theme)}
  }

  &:focus-within {
    ${({ theme: theme2, isActive: isActive2 }) => activeRowStyle(theme2, isActive2)}
  }
  
`;
const Wrapper$4 = styled__default.default.div`
  flex: 1;
  display: flex;
  align-items: center;
  height: ${rowHeight};
  background-color: ${({ isGrey, theme }) => isGrey ? theme.colors.neutral100 : theme.colors.neutral0};
  border: 1px solid transparent;
`;
const BoxWrapper = styled__default.default.div`
  display: inline-flex;
  min-width: 100%;

  ${ConditionsButton$1} {
    display: none;
  }
  ${({ isActive, theme }) => isActive && activeRowStyle(theme, isActive)}
  &:hover {
    ${({ theme, isActive }) => activeRowStyle(theme, isActive)}
  }
`;
const Cell$2 = styled__default.default(designSystem.Flex)`
  width: ${cellWidth};
  position: relative;
`;
const Chevron = styled__default.default(designSystem.Box)`
  display: none;
  svg {
    width: 11px;
  }
  * {
    fill: ${({ theme }) => theme.colors.primary600};
  }
`;
const TinyDot = styled__default.default.span`
  position: absolute;
  top: -6px;
  left: 37px;
  width: 6px;
  height: 6px;
  border-radius: 20px;
  background: ${({ theme }) => theme.colors.primary600};
`;
const AbsoluteBox = styled__default.default(designSystem.Box)`
  position: absolute;
  right: 9px;
  transform: translateY(10px);
`;
const Collapse = ({
  availableActions,
  isActive,
  isGrey,
  isFormDisabled,
  label,
  onClickToggle,
  pathToData
}) => {
  const [isModalOpen, setModalOpen] = React.useState(false);
  const { formatMessage } = reactIntl.useIntl();
  const { modifiedData, onChangeParentCheckbox, onChangeSimpleCheckbox } = usePermissionsDataManager();
  const handleToggleModalIsOpen = () => {
    setModalOpen((s) => !s);
  };
  const handleModalClose = () => {
    setModalOpen(false);
  };
  const mainData = get__default.default(modifiedData, pathToData.split(".."), {});
  const dataWithoutCondition = React.useMemo(() => {
    return Object.keys(mainData).reduce((acc, current) => {
      acc[current] = omit__default.default(mainData[current], "conditions");
      return acc;
    }, {});
  }, [mainData]);
  const { hasAllActionsSelected, hasSomeActionsSelected } = getCheckboxState(dataWithoutCondition);
  const checkboxesActions = React.useMemo(() => {
    return generateCheckboxesActions(availableActions, modifiedData, pathToData);
  }, [availableActions, modifiedData, pathToData]);
  const doesConditionButtonHasConditions = checkboxesActions.some(
    ({ hasConditions }) => hasConditions
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(BoxWrapper, { isActive, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(Wrapper$4, { isGrey, children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        RowLabelWithCheckbox$1,
        {
          isCollapsable: true,
          isFormDisabled,
          label,
          checkboxName: pathToData,
          onChange: onChangeParentCheckbox,
          onClick: onClickToggle,
          someChecked: hasSomeActionsSelected,
          value: hasAllActionsSelected,
          isActive,
          children: /* @__PURE__ */ jsxRuntime.jsx(Chevron, { paddingLeft: 2, children: isActive ? /* @__PURE__ */ jsxRuntime.jsx(Icons.ChevronUp, {}) : /* @__PURE__ */ jsxRuntime.jsx(Icons.ChevronDown, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { style: { flex: 1 }, children: checkboxesActions.map(
        ({
          actionId,
          hasConditions,
          hasAllActionsSelected: hasAllActionsSelected2,
          hasSomeActionsSelected: hasSomeActionsSelected2,
          isDisplayed,
          isParentCheckbox,
          checkboxName,
          label: permissionLabel
        }) => {
          if (!isDisplayed) {
            return /* @__PURE__ */ jsxRuntime.jsx(HiddenAction, {}, actionId);
          }
          if (isParentCheckbox) {
            return /* @__PURE__ */ jsxRuntime.jsxs(Cell$2, { justifyContent: "center", alignItems: "center", children: [
              hasConditions && /* @__PURE__ */ jsxRuntime.jsx(TinyDot, {}),
              /* @__PURE__ */ jsxRuntime.jsx(
                designSystem.BaseCheckbox,
                {
                  disabled: isFormDisabled,
                  name: checkboxName,
                  "aria-label": formatMessage(
                    {
                      id: `Settings.permissions.select-by-permission`,
                      defaultMessage: "Select {label} permission"
                    },
                    { label: `${permissionLabel} ${label}` }
                  ),
                  onValueChange: (value) => {
                    onChangeParentCheckbox({
                      target: {
                        name: checkboxName,
                        value
                      }
                    });
                  },
                  indeterminate: hasSomeActionsSelected2,
                  value: hasAllActionsSelected2
                }
              )
            ] }, actionId);
          }
          return /* @__PURE__ */ jsxRuntime.jsxs(Cell$2, { justifyContent: "center", alignItems: "center", children: [
            hasConditions && /* @__PURE__ */ jsxRuntime.jsx(TinyDot, {}),
            /* @__PURE__ */ jsxRuntime.jsx(
              designSystem.BaseCheckbox,
              {
                disabled: isFormDisabled,
                indeterminate: hasConditions,
                name: checkboxName,
                onValueChange: (value) => {
                  onChangeSimpleCheckbox({
                    target: {
                      name: checkboxName,
                      value
                    }
                  });
                },
                value: hasAllActionsSelected2
              }
            )
          ] }, actionId);
        }
      ) }),
      isModalOpen && /* @__PURE__ */ jsxRuntime.jsx(
        ConditionsModal,
        {
          headerBreadCrumbs: [label, "Settings.permissions.conditions.conditions"],
          actions: checkboxesActions,
          isFormDisabled,
          onClosed: handleModalClose,
          onToggle: handleToggleModalIsOpen
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(AbsoluteBox, { children: /* @__PURE__ */ jsxRuntime.jsx(
      ConditionsButton$1,
      {
        onClick: handleToggleModalIsOpen,
        hasConditions: doesConditionButtonHasConditions
      }
    ) })
  ] });
};
Collapse.propTypes = {
  availableActions: PropTypes__default.default.array.isRequired,
  isActive: PropTypes__default.default.bool.isRequired,
  isGrey: PropTypes__default.default.bool.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  label: PropTypes__default.default.string.isRequired,
  onClickToggle: PropTypes__default.default.func.isRequired,
  pathToData: PropTypes__default.default.string.isRequired
};
const Required = styled__default.default.span`
  color: ${({ theme }) => theme.colors.danger700};
  padding-left: ${({ theme }) => theme.spaces[1]}px;
`;
const RequiredSign = () => /* @__PURE__ */ jsxRuntime.jsx(Required, { children: "*" });
const getAvailableActions = (actions, targetSubject) => {
  return actions.map((action) => {
    const isDisplayed = Array.isArray(action.subjects) && action.subjects.indexOf(targetSubject) !== -1;
    return { ...action, isDisplayed };
  });
};
const StyledBox$1 = styled__default.default(designSystem.Box)`
  transform: translate(-4px, -12px);

  &:before {
    content: '';
    width: ${4 / 16}rem;
    height: ${12 / 16}rem;
    background: ${({ theme }) => theme.colors.primary200};
    display: block;
  }
`;
const Svg = styled__default.default.svg`
  position: relative;
  flex-shrink: 0;
  transform: translate(-0.5px, -1px);

  * {
    fill: ${({ theme, color }) => theme.colors[color]};
  }
`;
const Curve = (props) => /* @__PURE__ */ jsxRuntime.jsx(StyledBox$1, { children: /* @__PURE__ */ jsxRuntime.jsx(
  Svg,
  {
    width: "20",
    height: "23",
    viewBox: "0 0 20 23",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...props,
    children: /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7.02477 14.7513C8.65865 17.0594 11.6046 18.6059 17.5596 18.8856C18.6836 18.9384 19.5976 19.8435 19.5976 20.9688V20.9688C19.5976 22.0941 18.6841 23.0125 17.5599 22.9643C10.9409 22.6805 6.454 20.9387 3.75496 17.1258C0.937988 13.1464 0.486328 7.39309 0.486328 0.593262H4.50974C4.50974 7.54693 5.06394 11.9813 7.02477 14.7513Z",
        fill: "#D9D8FF"
      }
    )
  }
) });
Curve.defaultProps = {
  fill: "primary200"
};
Curve.propTypes = {
  fill: PropTypes__default.default.string
};
const Curve$1 = React.memo(Curve);
const Cell$1 = styled__default.default(designSystem.Flex)`
  width: ${cellWidth};
  position: relative;
`;
const RowWrapper = styled__default.default(designSystem.Flex)`
  height: ${rowHeight};
`;
const Wrapper$3 = styled__default.default(designSystem.Box)`
  padding-left: ${31 / 16}rem;
`;
const LeftBorderTimeline = styled__default.default(designSystem.Box)`
  border-left: ${({ isVisible, theme }) => isVisible ? `4px solid ${theme.colors.primary200}` : "4px solid transparent"};
`;
const RowStyle = styled__default.default(designSystem.Flex)`
  padding-left: ${({ theme }) => theme.spaces[4]};
  width: ${({ level }) => 145 - level * 36}px;

  ${({ isCollapsable, theme }) => isCollapsable && `
      ${CarretIcon} {
        display: block;
        color: ${theme.colors.neutral100};
      }
      &:hover {
        ${activeStyle(theme)}
      }
  `}
  ${({ isActive, theme }) => isActive && activeStyle(theme)};
`;
const TopTimeline = styled__default.default.div`
  padding-top: ${({ theme }) => theme.spaces[2]};
  margin-top: ${({ theme }) => theme.spaces[2]};
  width: ${4 / 16}rem;
  background-color: ${({ theme }) => theme.colors.primary200};
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
`;
const SubActionRow = ({
  childrenForm,
  isFormDisabled,
  recursiveLevel,
  pathToDataFromActionRow,
  propertyActions,
  parentName,
  propertyName
}) => {
  const { formatMessage } = reactIntl.useIntl();
  const { modifiedData, onChangeParentCheckbox, onChangeSimpleCheckbox } = usePermissionsDataManager();
  const [rowToOpen, setRowToOpen] = React.useState(null);
  const handleClickToggleSubLevel = (name) => {
    setRowToOpen((prev) => {
      if (prev === name) {
        return null;
      }
      return name;
    });
  };
  const displayedRecursiveChildren = React.useMemo(() => {
    if (!rowToOpen) {
      return null;
    }
    return childrenForm.find(({ value }) => value === rowToOpen);
  }, [rowToOpen, childrenForm]);
  return /* @__PURE__ */ jsxRuntime.jsxs(Wrapper$3, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(TopTimeline, {}),
    childrenForm.map(({ label, value, required, children: subChildrenForm }, index) => {
      const isVisible = index + 1 < childrenForm.length;
      const isArrayType = Array.isArray(subChildrenForm);
      const isActive = rowToOpen === value;
      return /* @__PURE__ */ jsxRuntime.jsxs(LeftBorderTimeline, { isVisible, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(RowWrapper, { children: [
          /* @__PURE__ */ jsxRuntime.jsx(Curve$1, { color: "primary200" }),
          /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { style: { flex: 1 }, children: [
            /* @__PURE__ */ jsxRuntime.jsx(RowStyle, { level: recursiveLevel, isActive, isCollapsable: isArrayType, children: /* @__PURE__ */ jsxRuntime.jsxs(
              CollapseLabel,
              {
                alignItems: "center",
                isCollapsable: isArrayType,
                ...isArrayType && {
                  onClick: () => handleClickToggleSubLevel(value),
                  "aria-expanded": isActive,
                  onKeyDown: ({ key }) => (key === "Enter" || key === " ") && handleClickToggleSubLevel(value),
                  tabIndex: 0,
                  role: "button"
                },
                title: label,
                children: [
                  /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { ellipsis: true, children: upperFirst__default.default(label) }),
                  required && /* @__PURE__ */ jsxRuntime.jsx(RequiredSign, {}),
                  /* @__PURE__ */ jsxRuntime.jsx(CarretIcon, { $isActive: isActive })
                ]
              }
            ) }),
            /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { style: { flex: 1 }, children: propertyActions.map(
              ({ actionId, label: propertyLabel, isActionRelatedToCurrentProperty }) => {
                if (!isActionRelatedToCurrentProperty) {
                  return /* @__PURE__ */ jsxRuntime.jsx(HiddenAction, {}, actionId);
                }
                const checkboxName = [
                  ...pathToDataFromActionRow.split(".."),
                  actionId,
                  "properties",
                  propertyName,
                  ...parentName.split(".."),
                  value
                ];
                const checkboxValue = get__default.default(modifiedData, checkboxName, false);
                if (!subChildrenForm) {
                  return /* @__PURE__ */ jsxRuntime.jsx(Cell$1, { justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
                    designSystem.BaseCheckbox,
                    {
                      disabled: isFormDisabled,
                      name: checkboxName.join(".."),
                      "aria-label": formatMessage(
                        {
                          id: `Settings.permissions.select-by-permission`,
                          defaultMessage: "Select {label} permission"
                        },
                        { label: `${parentName} ${label} ${propertyLabel}` }
                      ),
                      onValueChange: (value2) => {
                        onChangeSimpleCheckbox({
                          target: {
                            name: checkboxName.join(".."),
                            value: value2
                          }
                        });
                      },
                      value: checkboxValue
                    }
                  ) }, propertyLabel);
                }
                const { hasAllActionsSelected, hasSomeActionsSelected } = getCheckboxState(checkboxValue);
                return /* @__PURE__ */ jsxRuntime.jsx(Cell$1, { justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
                  designSystem.BaseCheckbox,
                  {
                    disabled: isFormDisabled,
                    name: checkboxName.join(".."),
                    "aria-label": formatMessage(
                      {
                        id: `Settings.permissions.select-by-permission`,
                        defaultMessage: "Select {label} permission"
                      },
                      { label: `${parentName} ${label} ${propertyLabel}` }
                    ),
                    onValueChange: (value2) => {
                      onChangeParentCheckbox({
                        target: {
                          name: checkboxName.join(".."),
                          value: value2
                        }
                      });
                    },
                    value: hasAllActionsSelected,
                    indeterminate: hasSomeActionsSelected
                  },
                  propertyLabel
                ) }, propertyLabel);
              }
            ) })
          ] })
        ] }),
        displayedRecursiveChildren && isActive && /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { paddingBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
          SubActionRow,
          {
            isFormDisabled,
            parentName: `${parentName}..${value}`,
            pathToDataFromActionRow,
            propertyActions,
            propertyName,
            recursiveLevel: recursiveLevel + 1,
            childrenForm: displayedRecursiveChildren.children
          }
        ) })
      ] }, value);
    })
  ] });
};
SubActionRow.propTypes = {
  childrenForm: PropTypes__default.default.array.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  parentName: PropTypes__default.default.string.isRequired,
  pathToDataFromActionRow: PropTypes__default.default.string.isRequired,
  propertyActions: PropTypes__default.default.array.isRequired,
  propertyName: PropTypes__default.default.string.isRequired,
  recursiveLevel: PropTypes__default.default.number.isRequired
};
const SubActionRow$1 = React.memo(SubActionRow);
const getActionIdsFromPropertyActions = (propertyActions) => {
  const actionIds = propertyActions.reduce((acc, current) => {
    if (current.isActionRelatedToCurrentProperty) {
      acc.push(current.actionId);
    }
    return acc;
  }, []);
  return actionIds;
};
const getRowLabelCheckboxeState = (propertyActions, modifiedData, pathToContentType, propertyToCheck, targetKey) => {
  const actionIds = getActionIdsFromPropertyActions(propertyActions);
  const data = actionIds.reduce((acc, current) => {
    const pathToData = [
      ...pathToContentType.split(".."),
      current,
      "properties",
      propertyToCheck,
      targetKey
    ];
    const mainData = get__default.default(modifiedData, pathToData, false);
    acc[current] = mainData;
    return acc;
  }, {});
  return getCheckboxState(data);
};
const Cell = styled__default.default(designSystem.Flex)`
  width: ${cellWidth};
  position: relative;
`;
const Wrapper$2 = styled__default.default(designSystem.Flex)`
  height: ${rowHeight};
  flex: 1;

  ${({ isCollapsable, theme }) => isCollapsable && `
      ${CarretIcon} {
        display: block;
        color: ${theme.colors.neutral100};
      }
      &:hover {
        ${activeStyle(theme)}
      }
  `}
  ${({ isActive, theme }) => isActive && activeStyle(theme)};
`;
const ActionRow = ({
  childrenForm,
  label,
  isFormDisabled,
  name,
  required,
  pathToData,
  propertyActions,
  propertyName,
  isOdd
}) => {
  const { formatMessage } = reactIntl.useIntl();
  const [rowToOpen, setRowToOpen] = React.useState(null);
  const {
    modifiedData,
    onChangeCollectionTypeLeftActionRowCheckbox,
    onChangeParentCheckbox,
    onChangeSimpleCheckbox
  } = usePermissionsDataManager();
  const isActive = rowToOpen === name;
  const recursiveChildren = React.useMemo(() => {
    if (!Array.isArray(childrenForm)) {
      return [];
    }
    return childrenForm;
  }, [childrenForm]);
  const isCollapsable = recursiveChildren.length > 0;
  const handleClick = React.useCallback(() => {
    if (isCollapsable) {
      setRowToOpen((prev) => {
        if (prev === name) {
          return null;
        }
        return name;
      });
    }
  }, [isCollapsable, name]);
  const handleChangeLeftRowCheckbox = ({ target: { value } }) => {
    onChangeCollectionTypeLeftActionRowCheckbox(pathToData, propertyName, name, value);
  };
  const { hasAllActionsSelected, hasSomeActionsSelected } = React.useMemo(() => {
    return getRowLabelCheckboxeState(propertyActions, modifiedData, pathToData, propertyName, name);
  }, [propertyActions, modifiedData, pathToData, propertyName, name]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Wrapper$2,
      {
        alignItems: "center",
        isCollapsable,
        isActive,
        background: isOdd ? "neutral100" : "neutral0",
        children: /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { children: [
          /* @__PURE__ */ jsxRuntime.jsxs(
            RowLabelWithCheckbox$1,
            {
              onChange: handleChangeLeftRowCheckbox,
              onClick: handleClick,
              isCollapsable,
              isFormDisabled,
              label,
              someChecked: hasSomeActionsSelected,
              value: hasAllActionsSelected,
              isActive,
              children: [
                required && /* @__PURE__ */ jsxRuntime.jsx(RequiredSign, {}),
                /* @__PURE__ */ jsxRuntime.jsx(CarretIcon, { $isActive: isActive })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { children: propertyActions.map(({ label: label2, isActionRelatedToCurrentProperty, actionId }) => {
            if (!isActionRelatedToCurrentProperty) {
              return /* @__PURE__ */ jsxRuntime.jsx(HiddenAction, {}, label2);
            }
            const checkboxName = [
              ...pathToData.split(".."),
              actionId,
              "properties",
              propertyName,
              name
            ];
            if (!isCollapsable) {
              const checkboxValue = get__default.default(modifiedData, checkboxName, false);
              return /* @__PURE__ */ jsxRuntime.jsx(Cell, { justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
                designSystem.BaseCheckbox,
                {
                  disabled: isFormDisabled,
                  name: checkboxName.join(".."),
                  "aria-label": formatMessage(
                    {
                      id: `Settings.permissions.select-by-permission`,
                      defaultMessage: "Select {label} permission"
                    },
                    { label: `${name} ${label2}` }
                  ),
                  onValueChange: (value) => {
                    onChangeSimpleCheckbox({
                      target: {
                        name: checkboxName.join(".."),
                        value
                      }
                    });
                  },
                  value: checkboxValue
                }
              ) }, actionId);
            }
            const data = get__default.default(modifiedData, checkboxName, {});
            const { hasAllActionsSelected: hasAllActionsSelected2, hasSomeActionsSelected: hasSomeActionsSelected2 } = getCheckboxState(data);
            return /* @__PURE__ */ jsxRuntime.jsx(Cell, { justifyContent: "center", alignItems: "center", children: /* @__PURE__ */ jsxRuntime.jsx(
              designSystem.BaseCheckbox,
              {
                disabled: isFormDisabled,
                name: checkboxName.join(".."),
                onValueChange: (value) => {
                  onChangeParentCheckbox({
                    target: {
                      name: checkboxName.join(".."),
                      value
                    }
                  });
                },
                "aria-label": formatMessage(
                  {
                    id: `Settings.permissions.select-by-permission`,
                    defaultMessage: "Select {label} permission"
                  },
                  { label: `${name} ${label2}` }
                ),
                value: hasAllActionsSelected2,
                indeterminate: hasSomeActionsSelected2
              }
            ) }, label2);
          }) })
        ] })
      }
    ),
    isActive && /* @__PURE__ */ jsxRuntime.jsx(
      SubActionRow$1,
      {
        childrenForm: recursiveChildren,
        isFormDisabled,
        parentName: name,
        pathToDataFromActionRow: pathToData,
        propertyName,
        propertyActions,
        recursiveLevel: 0
      }
    )
  ] });
};
ActionRow.defaultProps = {
  childrenForm: [],
  required: false
};
ActionRow.propTypes = {
  childrenForm: PropTypes__default.default.array,
  label: PropTypes__default.default.string.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  name: PropTypes__default.default.string.isRequired,
  pathToData: PropTypes__default.default.string.isRequired,
  propertyActions: PropTypes__default.default.array.isRequired,
  propertyName: PropTypes__default.default.string.isRequired,
  required: PropTypes__default.default.bool,
  isOdd: PropTypes__default.default.bool.isRequired
};
const ActionRow$1 = React.memo(ActionRow);
const HeaderLabel = styled__default.default(designSystem.Flex)`
  width: ${cellWidth};
  flex-shrink: 0;
`;
const PropertyLabelWrapper = styled__default.default(designSystem.Flex)`
  width: ${firstRowWidth};
  height: ${rowHeight};
  flex-shrink: 0;
`;
const Header = ({ headers, label }) => {
  const { formatMessage } = reactIntl.useIntl();
  const translatedLabel = formatMessage(
    {
      id: "Settings.roles.form.permission.property-label",
      defaultMessage: "{label} permissions"
    },
    { label }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(PropertyLabelWrapper, { alignItems: "center", paddingLeft: 6, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "sigma", textColor: "neutral500", children: translatedLabel }) }),
    headers.map((header) => {
      if (!header.isActionRelatedToCurrentProperty) {
        return /* @__PURE__ */ jsxRuntime.jsx(HeaderLabel, {}, header.label);
      }
      return /* @__PURE__ */ jsxRuntime.jsx(HeaderLabel, { justifyContent: "center", children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "sigma", textColor: "neutral500", children: formatMessage({
        id: `Settings.roles.form.permissions.${header.label.toLowerCase()}`,
        defaultMessage: header.label
      }) }) }, header.label);
    })
  ] });
};
Header.propTypes = {
  headers: PropTypes__default.default.arrayOf(
    PropTypes__default.default.shape({
      label: PropTypes__default.default.string.isRequired,
      isActionRelatedToCurrentProperty: PropTypes__default.default.bool.isRequired
    })
  ).isRequired,
  label: PropTypes__default.default.string.isRequired
};
const generateHeadersFromActions = (actions, propertyName) => {
  return actions.map((action) => {
    const isActionRelatedToCurrentProperty = Array.isArray(action.applyToProperties) && action.applyToProperties.indexOf(propertyName) !== -1 && action.isDisplayed;
    return { label: action.label, actionId: action.actionId, isActionRelatedToCurrentProperty };
  });
};
const Wrapper$1 = styled__default.default.div`
  display: inline-flex;
  flex-direction: column;
  min-width: 0;
`;
const CollapsePropertyMatrix = ({
  availableActions,
  childrenForm,
  isFormDisabled,
  label,
  pathToData,
  propertyName
}) => {
  const propertyActions = React.useMemo(
    () => generateHeadersFromActions(availableActions, propertyName),
    [availableActions, propertyName]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(Wrapper$1, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(Header, { label, headers: propertyActions }),
    /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { children: childrenForm.map(({ children: childrenForm2, label: label2, value, required }, i) => /* @__PURE__ */ jsxRuntime.jsx(
      ActionRow$1,
      {
        childrenForm: childrenForm2,
        label: label2,
        isFormDisabled,
        name: value,
        required,
        propertyActions,
        pathToData,
        propertyName,
        isOdd: i % 2 === 0
      },
      value
    )) })
  ] });
};
CollapsePropertyMatrix.propTypes = {
  childrenForm: PropTypes__default.default.array.isRequired,
  availableActions: PropTypes__default.default.array.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  label: PropTypes__default.default.string.isRequired,
  pathToData: PropTypes__default.default.string.isRequired,
  propertyName: PropTypes__default.default.string.isRequired
};
const Wrapper = styled__default.default.div`
  flex-direction: column;
  display: inline-flex;
  min-width: 100%;
  ${({ theme, isActive }) => isActive && `border: 1px solid ${theme.colors.primary600};`}
`;
const ContentTypeCollapse = ({
  allActions,
  contentTypeName,
  label,
  index,
  isActive,
  isFormDisabled,
  onClickToggleCollapse,
  pathToData,
  properties
}) => {
  const handleClickToggleCollapse = React.useCallback(() => {
    onClickToggleCollapse(contentTypeName);
  }, [contentTypeName, onClickToggleCollapse]);
  const availableActions = React.useMemo(() => {
    return getAvailableActions(allActions, contentTypeName);
  }, [allActions, contentTypeName]);
  return /* @__PURE__ */ jsxRuntime.jsxs(Wrapper, { isActive, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Collapse,
      {
        availableActions,
        isActive,
        isGrey: index % 2 === 0,
        isFormDisabled,
        label,
        onClickToggle: handleClickToggleCollapse,
        pathToData
      }
    ),
    isActive && properties.map(({ label: propertyLabel, value, children: childrenForm }) => {
      return /* @__PURE__ */ jsxRuntime.jsx(
        CollapsePropertyMatrix,
        {
          availableActions,
          childrenForm,
          isFormDisabled,
          label: propertyLabel,
          pathToData,
          propertyName: value
        },
        value
      );
    })
  ] });
};
ContentTypeCollapse.propTypes = {
  allActions: PropTypes__default.default.array.isRequired,
  contentTypeName: PropTypes__default.default.string.isRequired,
  index: PropTypes__default.default.number.isRequired,
  isActive: PropTypes__default.default.bool.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  label: PropTypes__default.default.string.isRequired,
  onClickToggleCollapse: PropTypes__default.default.func.isRequired,
  pathToData: PropTypes__default.default.string.isRequired,
  properties: PropTypes__default.default.array.isRequired
};
const ContentTypeCollapses = ({ actions, isFormDisabled, pathToData, subjects }) => {
  const [collapseToOpen, setCollapseToOpen] = React.useState(null);
  const handleClickToggleCollapse = (collapseName) => {
    const nextCollapseToOpen = collapseToOpen === collapseName ? null : collapseName;
    setCollapseToOpen(nextCollapseToOpen);
  };
  return subjects.map(({ uid, label, properties }, index) => {
    return /* @__PURE__ */ jsxRuntime.jsx(
      ContentTypeCollapse,
      {
        allActions: actions,
        contentTypeName: uid,
        label,
        isActive: collapseToOpen === uid,
        isFormDisabled,
        index,
        onClickToggleCollapse: handleClickToggleCollapse,
        pathToData: `${pathToData}..${uid}`,
        properties
      },
      uid
    );
  });
};
ContentTypeCollapses.defaultProps = {
  actions: [],
  subjects: []
};
ContentTypeCollapses.propTypes = {
  actions: PropTypes__default.default.array.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  pathToData: PropTypes__default.default.string.isRequired,
  subjects: PropTypes__default.default.arrayOf(
    PropTypes__default.default.shape({
      uid: PropTypes__default.default.string.isRequired,
      label: PropTypes__default.default.string.isRequired,
      properties: PropTypes__default.default.array.isRequired
    })
  )
};
const ContentTypeCollapses$1 = React.memo(ContentTypeCollapses);
const findDisplayedActions = (actions) => actions.filter(({ subjects }) => subjects && subjects.length);
const getActionsIds = (array) => array.map(({ actionId }) => actionId);
const getRelatedActionIdData = (actionIdArray, dataObj) => {
  return actionIdArray.reduce((acc, actionId) => {
    Object.keys(dataObj).forEach((ctUid) => {
      const actionIdData = get__default.default(dataObj, [ctUid, actionId], {});
      const actionIdState = { [ctUid]: removeConditionKeyFromData(actionIdData) };
      if (!acc[actionId]) {
        acc[actionId] = actionIdState;
      } else {
        acc[actionId] = { ...acc[actionId], ...actionIdState };
      }
    });
    return acc;
  }, {});
};
const getCheckboxesState = (properties, modifiedData) => {
  const actionsIds = getActionsIds(properties);
  const relatedActionsData = getRelatedActionIdData(actionsIds, modifiedData);
  const checkboxesState = Object.keys(relatedActionsData).reduce((acc, current) => {
    acc[current] = getCheckboxState(relatedActionsData[current]);
    return acc;
  }, {});
  return checkboxesState;
};
const CenteredStack = styled__default.default(designSystem.Flex)`
  width: ${cellWidth};
  flex-shrink: 0;
`;
const GlobalActions = ({ actions, isFormDisabled, kind }) => {
  const { formatMessage } = reactIntl.useIntl();
  const { modifiedData, onChangeCollectionTypeGlobalActionCheckbox } = usePermissionsDataManager();
  const displayedActions = React.useMemo(() => {
    return findDisplayedActions(actions);
  }, [actions]);
  const checkboxesState = React.useMemo(() => {
    return getCheckboxesState(displayedActions, modifiedData[kind]);
  }, [modifiedData, displayedActions, kind]);
  return /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { paddingBottom: 4, paddingTop: 6, style: { paddingLeft: firstRowWidth }, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Flex, { gap: 0, children: displayedActions.map(({ label, actionId }) => {
    return /* @__PURE__ */ jsxRuntime.jsxs(
      CenteredStack,
      {
        direction: "column",
        alignItems: "center",
        justifyContent: "center",
        gap: 3,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "sigma", textColor: "neutral500", children: formatMessage({
            id: `Settings.roles.form.permissions.${label.toLowerCase()}`,
            defaultMessage: label
          }) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            designSystem.BaseCheckbox,
            {
              disabled: isFormDisabled,
              onValueChange: (value) => {
                onChangeCollectionTypeGlobalActionCheckbox(kind, actionId, value);
              },
              name: actionId,
              "aria-label": formatMessage(
                {
                  id: `Settings.permissions.select-all-by-permission`,
                  defaultMessage: "Select all {label} permissions"
                },
                {
                  label: formatMessage({
                    id: `Settings.roles.form.permissions.${label.toLowerCase()}`,
                    defaultMessage: label
                  })
                }
              ),
              value: get__default.default(checkboxesState, [actionId, "hasAllActionsSelected"], false),
              indeterminate: get__default.default(checkboxesState, [actionId, "hasSomeActionsSelected"], false)
            }
          )
        ]
      },
      actionId
    );
  }) }) });
};
GlobalActions.defaultProps = {
  actions: []
};
GlobalActions.propTypes = {
  actions: PropTypes__default.default.arrayOf(
    PropTypes__default.default.shape({
      label: PropTypes__default.default.string.isRequired,
      actionId: PropTypes__default.default.string.isRequired,
      subjects: PropTypes__default.default.array.isRequired
    })
  ),
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  kind: PropTypes__default.default.string.isRequired
};
const GlobalActions$1 = React.memo(GlobalActions);
const StyledBox = styled__default.default(designSystem.Box)`
  overflow-x: auto;
`;
const ContentTypes = ({ isFormDisabled, kind, layout: { actions, subjects } }) => {
  const sortedSubjects = sortBy__default.default([...subjects], "label");
  return /* @__PURE__ */ jsxRuntime.jsxs(StyledBox, { background: "neutral0", children: [
    /* @__PURE__ */ jsxRuntime.jsx(GlobalActions$1, { actions, kind, isFormDisabled }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ContentTypeCollapses$1,
      {
        actions,
        isFormDisabled,
        pathToData: kind,
        subjects: sortedSubjects
      }
    )
  ] });
};
ContentTypes.propTypes = {
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  kind: PropTypes__default.default.string.isRequired,
  layout: PropTypes__default.default.shape({
    actions: PropTypes__default.default.array,
    subjects: PropTypes__default.default.arrayOf(
      PropTypes__default.default.shape({
        uid: PropTypes__default.default.string.isRequired,
        label: PropTypes__default.default.string.isRequired,
        properties: PropTypes__default.default.array.isRequired
      })
    )
  }).isRequired
};
const ContentTypes$1 = React.memo(ContentTypes);
const formatActions = (actions, modifiedData, pathToData) => {
  return actions.map((action) => {
    const checkboxName = [...pathToData, action.action, "properties", "enabled"];
    const checkboxValue = get__default.default(modifiedData, checkboxName, false);
    const conditionValue = get__default.default(modifiedData, [...pathToData, action.action, "conditions"], {});
    const hasConditions = createArrayOfValues(conditionValue).some((val) => val);
    return {
      ...action,
      isDisplayed: checkboxValue,
      checkboxName: checkboxName.join(".."),
      hasSomeActionsSelected: checkboxValue,
      value: checkboxValue,
      hasConditions,
      label: action.displayName,
      actionId: action.action,
      pathToConditionsObject: [...pathToData, action.action]
    };
  });
};
const getConditionsButtonState = (valueObj) => {
  const relatedData = Object.entries(valueObj).reduce((acc, current) => {
    const [catName, { conditions }] = current;
    acc[catName] = conditions;
    return acc;
  }, {});
  const arrayOfValues = createArrayOfValues(relatedData);
  return arrayOfValues.some((val) => val);
};
const Border = styled__default.default.div`
  flex: 1;
  align-self: center;
  border-top: 1px solid ${({ theme }) => theme.colors.neutral150};
`;
const CheckboxWrapper = styled__default.default.div`
  position: relative;
  word-break: keep-all;
  ${({ hasConditions, disabled, theme }) => hasConditions && `
    &:before {
      content: '';
      position: absolute;
      top: ${-4 / 16}rem;
      left: ${-8 / 16}rem;
      width: ${6 / 16}rem;
      height: ${6 / 16}rem;
      border-radius: ${20 / 16}rem;
      background: ${disabled ? theme.colors.neutral100 : theme.colors.primary600};
    }
  `}
`;
const SubCategory = ({ categoryName, isFormDisabled, subCategoryName, actions, pathToData }) => {
  const [isModalOpen, setModalOpen] = React.useState(false);
  const { modifiedData, onChangeParentCheckbox, onChangeSimpleCheckbox } = usePermissionsDataManager();
  const { formatMessage } = reactIntl.useIntl();
  const mainData = get__default.default(modifiedData, pathToData, {});
  const dataWithoutCondition = React.useMemo(() => {
    return Object.keys(mainData).reduce((acc, current) => {
      acc[current] = removeConditionKeyFromData(mainData[current]);
      return acc;
    }, {});
  }, [mainData]);
  const { hasAllActionsSelected, hasSomeActionsSelected } = getCheckboxState(dataWithoutCondition);
  const handleToggleModalIsOpen = () => {
    setModalOpen((s) => !s);
  };
  const handleModalClose = () => {
    setModalOpen(false);
  };
  const formattedActions = formatActions(actions, modifiedData, pathToData);
  const doesButtonHasCondition = getConditionsButtonState(get__default.default(modifiedData, [...pathToData], {}));
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Box, { children: [
      /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { justifyContent: "space-between", alignItems: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { paddingRight: 4, children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "sigma", textColor: "neutral600", children: subCategoryName }) }),
        /* @__PURE__ */ jsxRuntime.jsx(Border, {}),
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { paddingLeft: 4, children: /* @__PURE__ */ jsxRuntime.jsx(
          designSystem.Checkbox,
          {
            name: pathToData.join(".."),
            disabled: isFormDisabled,
            onValueChange: (value) => {
              onChangeParentCheckbox({
                target: {
                  name: pathToData.join(".."),
                  value
                }
              });
            },
            indeterminate: hasSomeActionsSelected,
            value: hasAllActionsSelected,
            children: formatMessage({ id: "app.utils.select-all", defaultMessage: "Select all" })
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { paddingTop: 6, paddingBottom: 6, children: [
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.Grid, { gap: 2, style: { flex: 1 }, children: formattedActions.map(({ checkboxName, value, action, displayName, hasConditions }) => {
          return /* @__PURE__ */ jsxRuntime.jsx(designSystem.GridItem, { col: 3, children: /* @__PURE__ */ jsxRuntime.jsx(CheckboxWrapper, { disabled: isFormDisabled, hasConditions, children: /* @__PURE__ */ jsxRuntime.jsx(
            designSystem.Checkbox,
            {
              name: checkboxName,
              disabled: isFormDisabled,
              onValueChange: (value2) => {
                onChangeSimpleCheckbox({
                  target: {
                    name: checkboxName,
                    value: value2
                  }
                });
              },
              value,
              children: displayName
            }
          ) }) }, action);
        }) }),
        /* @__PURE__ */ jsxRuntime.jsx(
          ConditionsButton$1,
          {
            hasConditions: doesButtonHasCondition,
            onClick: handleToggleModalIsOpen
          }
        )
      ] })
    ] }),
    isModalOpen && /* @__PURE__ */ jsxRuntime.jsx(
      ConditionsModal,
      {
        headerBreadCrumbs: [categoryName, subCategoryName],
        actions: formattedActions,
        isFormDisabled,
        onClosed: handleModalClose,
        onToggle: handleToggleModalIsOpen
      }
    )
  ] });
};
SubCategory.propTypes = {
  actions: PropTypes__default.default.array.isRequired,
  categoryName: PropTypes__default.default.string.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  subCategoryName: PropTypes__default.default.string.isRequired,
  pathToData: PropTypes__default.default.array.isRequired
};
const PermissionRow = ({
  childrenForm,
  kind,
  name,
  isOpen,
  isFormDisabled,
  isWhite,
  onOpenCategory,
  pathToData
}) => {
  const { formatMessage } = reactIntl.useIntl();
  const handleClick = () => {
    onOpenCategory(name);
  };
  const categoryName = React.useMemo(() => {
    const split = name.split("::");
    return split.pop();
  }, [name]);
  return /* @__PURE__ */ jsxRuntime.jsxs(
    designSystem.Accordion,
    {
      expanded: isOpen,
      onToggle: handleClick,
      id: `accordion-${name}`,
      variant: isWhite ? "primary" : "secondary",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          designSystem.AccordionToggle,
          {
            title: upperFirst__default.default(categoryName),
            description: `${formatMessage(
              { id: "Settings.permissions.category" },
              { category: categoryName }
            )} ${kind === "plugins" ? "plugin" : kind}`
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(designSystem.AccordionContent, { children: /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { padding: 6, children: childrenForm.map(({ actions, subCategoryName, subCategoryId }) => /* @__PURE__ */ jsxRuntime.jsx(
          SubCategory,
          {
            actions,
            categoryName,
            isFormDisabled,
            subCategoryName,
            pathToData: [...pathToData, subCategoryId]
          },
          subCategoryName
        )) }) })
      ]
    }
  );
};
PermissionRow.defaultProps = {};
PermissionRow.propTypes = {
  childrenForm: PropTypes__default.default.array.isRequired,
  isOpen: PropTypes__default.default.bool.isRequired,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  isWhite: PropTypes__default.default.bool.isRequired,
  kind: PropTypes__default.default.string.isRequired,
  name: PropTypes__default.default.string.isRequired,
  onOpenCategory: PropTypes__default.default.func.isRequired,
  pathToData: PropTypes__default.default.array.isRequired
};
const PluginsAndSettingsPermissions = ({ isFormDisabled, kind, layout }) => {
  const [openedCategory, setOpenedCategory] = React.useState(null);
  const handleOpenCategory = (categoryName) => {
    setOpenedCategory(categoryName === openedCategory ? null : categoryName);
  };
  return /* @__PURE__ */ jsxRuntime.jsx(designSystem.Box, { padding: 6, background: "neutral0", children: layout.map(({ category, categoryId, childrenForm }, index) => {
    return /* @__PURE__ */ jsxRuntime.jsx(
      PermissionRow,
      {
        childrenForm,
        kind,
        isFormDisabled,
        isOpen: openedCategory === category,
        isWhite: index % 2 === 1,
        name: category,
        onOpenCategory: handleOpenCategory,
        pathToData: [kind, categoryId]
      },
      category
    );
  }) });
};
PluginsAndSettingsPermissions.propTypes = {
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  kind: PropTypes__default.default.string.isRequired,
  layout: PropTypes__default.default.arrayOf(
    PropTypes__default.default.shape({
      category: PropTypes__default.default.string.isRequired,
      categoryId: PropTypes__default.default.string.isRequired,
      childrenForm: PropTypes__default.default.arrayOf(
        PropTypes__default.default.shape({
          actions: PropTypes__default.default.array.isRequired
        })
      ).isRequired
    }).isRequired
  ).isRequired
};
const findMatchingPermission = (permissions, action, subject) => permissions.find((perm) => perm.action === action && perm.subject === subject);
const createDefaultConditionsForm = (conditions, initialConditions = []) => conditions.reduce((acc, current) => {
  acc[current.id] = initialConditions.indexOf(current.id) !== -1;
  return acc;
}, {});
const createDefaultPropertyForms = ({ children }, propertyValues, prefix = "") => {
  return children.reduce((acc, current) => {
    if (current.children) {
      return {
        ...acc,
        [current.value]: createDefaultPropertyForms(
          current,
          propertyValues,
          `${prefix}${current.value}.`
        )
      };
    }
    const hasProperty = propertyValues.indexOf(`${prefix}${current.value}`) !== -1;
    acc[current.value] = hasProperty;
    return acc;
  }, {});
};
const createDefaultPropertiesForm = (propertiesArray, ctLayout, matchingPermission) => {
  return propertiesArray.reduce(
    (acc, currentPropertyName) => {
      const foundProperty = ctLayout.properties.find(({ value }) => value === currentPropertyName);
      if (foundProperty) {
        const matchingPermissionPropertyValues = get__default.default(
          matchingPermission,
          ["properties", foundProperty.value],
          []
        );
        const propertyForm = createDefaultPropertyForms(
          foundProperty,
          matchingPermissionPropertyValues
        );
        acc.properties[currentPropertyName] = propertyForm;
      }
      return acc;
    },
    { properties: {} }
  );
};
const findLayouts = (allLayouts, subjects) => {
  return subjects.reduce((acc, current) => {
    const foundLayout = allLayouts.find(({ uid }) => uid === current) || null;
    if (foundLayout) {
      acc[current] = foundLayout;
    }
    return acc;
  }, {});
};
const createDefaultCTFormFromLayout = ({ subjects }, actionArray, conditionArray, initialPermissions = []) => {
  return actionArray.reduce((defaultForm, current) => {
    const actionSubjects = current.subjects;
    const subjectLayouts = findLayouts(subjects, actionSubjects);
    if (isEmpty__default.default(subjectLayouts)) {
      return defaultForm;
    }
    const contentTypesActions = Object.keys(subjectLayouts).reduce((acc, currentCTUID) => {
      const { actionId, applyToProperties } = current;
      const currentSubjectLayout = subjectLayouts[currentCTUID];
      const properties = currentSubjectLayout.properties.map(({ value }) => value);
      const doesNothaveProperty = properties.every(
        (property) => (applyToProperties || []).indexOf(property) === -1
      );
      const matchingPermission = findMatchingPermission(initialPermissions, actionId, currentCTUID);
      const conditionsForm = createDefaultConditionsForm(
        conditionArray,
        get__default.default(matchingPermission, "conditions", [])
      );
      if (isEmpty__default.default(applyToProperties) || doesNothaveProperty) {
        set__default.default(acc, [currentCTUID, actionId], {
          properties: {
            enabled: matchingPermission !== void 0
          },
          conditions: conditionsForm
        });
        return acc;
      }
      const propertiesForm = createDefaultPropertiesForm(
        applyToProperties,
        subjectLayouts[currentCTUID],
        matchingPermission
      );
      set__default.default(acc, [currentCTUID, actionId], { ...propertiesForm, conditions: conditionsForm });
      return acc;
    }, {});
    return merge__default.default(defaultForm, contentTypesActions);
  }, {});
};
const createSubCategoryForm = (actions, conditions, permissions) => {
  return actions.reduce((acc, current) => {
    const foundMatchingPermission = findMatchingPermission(permissions, current.action, null);
    acc[current.action] = {
      properties: {
        enabled: foundMatchingPermission !== void 0
      },
      conditions: createDefaultConditionsForm(
        conditions,
        foundMatchingPermission?.conditions ?? []
      )
    };
    return acc;
  }, {});
};
const createChildrenDefaultForm = (childrenForm, conditions, initialPermissions) => {
  return childrenForm.reduce((acc, current) => {
    acc[current.subCategoryId] = createSubCategoryForm(
      current.actions,
      conditions,
      initialPermissions
    );
    return acc;
  }, {});
};
const createDefaultPluginsFormFromLayout = (pluginsLayout, conditions, initialPermissions = []) => {
  return pluginsLayout.reduce((acc, { categoryId, childrenForm }) => {
    const childrenDefaultForm = createChildrenDefaultForm(
      childrenForm,
      conditions,
      initialPermissions
    );
    acc[categoryId] = childrenDefaultForm;
    return acc;
  }, {});
};
const replaceName = (name) => name.split(" ").join("-");
const formatLayout = (layout, groupByKey) => {
  return Object.entries(groupBy__default.default(layout, groupByKey)).map(([itemName, item]) => ({
    category: itemName,
    categoryId: replaceName(itemName),
    childrenForm: Object.entries(groupBy__default.default(item, "subCategory")).map(
      ([subCategoryName, actions]) => ({
        subCategoryName,
        subCategoryId: replaceName(subCategoryName),
        actions
      })
    )
  }));
};
const init = (layout, permissions) => {
  const {
    conditions,
    sections: { collectionTypes, singleTypes, plugins, settings }
  } = layout;
  const layouts = {
    collectionTypes,
    singleTypes,
    plugins: formatLayout(plugins, "plugin"),
    settings: formatLayout(settings, "category")
  };
  const defaultForm = {
    collectionTypes: createDefaultCTFormFromLayout(
      collectionTypes,
      collectionTypes.actions || [],
      conditions,
      permissions
    ),
    singleTypes: createDefaultCTFormFromLayout(
      singleTypes,
      singleTypes.actions || [],
      conditions,
      permissions
    ),
    plugins: createDefaultPluginsFormFromLayout(layouts.plugins, conditions, permissions),
    settings: createDefaultPluginsFormFromLayout(layouts.settings, conditions, permissions)
  };
  return {
    initialData: defaultForm,
    modifiedData: defaultForm,
    layouts
  };
};
const updateConditionsToFalse = (obj) => {
  return Object.keys(obj).reduce((acc, current) => {
    const currentValue = obj[current];
    if (isObject__default.default(currentValue) && !has__default.default(currentValue, "conditions")) {
      return { ...acc, [current]: updateConditionsToFalse(currentValue) };
    }
    if (isObject__default.default(currentValue) && has__default.default(currentValue, "conditions")) {
      const isActionEnabled = createArrayOfValues(omit__default.default(currentValue, "conditions")).some(
        (val) => val
      );
      if (!isActionEnabled) {
        const updatedConditions = Object.keys(currentValue.conditions).reduce((acc1, current2) => {
          acc1[current2] = false;
          return acc1;
        }, {});
        return { ...acc, [current]: { ...currentValue, conditions: updatedConditions } };
      }
    }
    acc[current] = currentValue;
    return acc;
  }, {});
};
const updateValues = (obj, valueToSet, isFieldUpdate = false) => {
  return Object.keys(obj).reduce((acc, current) => {
    const currentValue = obj[current];
    if (current === "conditions" && !isFieldUpdate) {
      acc[current] = currentValue;
      return acc;
    }
    if (isObject__default.default(currentValue)) {
      return { ...acc, [current]: updateValues(currentValue, valueToSet, current === "fields") };
    }
    acc[current] = valueToSet;
    return acc;
  }, {});
};
const initialState = {
  initialData: {},
  modifiedData: {},
  layouts: {}
};
const reducer = (state, action) => produce__default.default(state, (draftState) => {
  switch (action.type) {
    case "ON_CHANGE_COLLECTION_TYPE_GLOBAL_ACTION_CHECKBOX": {
      const { collectionTypeKind, actionId, value } = action;
      const pathToData = ["modifiedData", collectionTypeKind];
      Object.keys(get__default.default(state, pathToData)).forEach((collectionType) => {
        const collectionTypeActionData = get__default.default(
          state,
          [...pathToData, collectionType, actionId],
          void 0
        );
        if (collectionTypeActionData) {
          let updatedValues = updateValues(collectionTypeActionData, value);
          if (!value && updatedValues.conditions) {
            const updatedConditions = updateValues(updatedValues.conditions, false);
            updatedValues = { ...updatedValues, conditions: updatedConditions };
          }
          set__default.default(draftState, [...pathToData, collectionType, actionId], updatedValues);
        }
      });
      break;
    }
    case "ON_CHANGE_COLLECTION_TYPE_ROW_LEFT_CHECKBOX": {
      const { pathToCollectionType, propertyName, rowName, value } = action;
      let nextModifiedDataState = cloneDeep__default.default(state.modifiedData);
      const pathToModifiedDataCollectionType = pathToCollectionType.split("..");
      const objToUpdate = get__default.default(nextModifiedDataState, pathToModifiedDataCollectionType, {});
      Object.keys(objToUpdate).forEach((actionId) => {
        if (has__default.default(objToUpdate[actionId], `properties.${propertyName}`)) {
          const objValue = get__default.default(objToUpdate, [actionId, "properties", propertyName, rowName]);
          const pathToDataToSet = [
            ...pathToModifiedDataCollectionType,
            actionId,
            "properties",
            propertyName,
            rowName
          ];
          if (!isObject__default.default(objValue)) {
            set__default.default(nextModifiedDataState, pathToDataToSet, value);
          } else {
            const updatedValue = updateValues(objValue, value);
            set__default.default(nextModifiedDataState, pathToDataToSet, updatedValue);
          }
        }
      });
      if (!value) {
        nextModifiedDataState = updateConditionsToFalse(nextModifiedDataState);
      }
      set__default.default(draftState, "modifiedData", nextModifiedDataState);
      break;
    }
    case "ON_CHANGE_CONDITIONS": {
      Object.entries(action.conditions).forEach((array) => {
        const [stringPathToData, conditionsToUpdate] = array;
        set__default.default(
          draftState,
          ["modifiedData", ...stringPathToData.split(".."), "conditions"],
          conditionsToUpdate
        );
      });
      break;
    }
    case "ON_CHANGE_SIMPLE_CHECKBOX": {
      let nextModifiedDataState = cloneDeep__default.default(state.modifiedData);
      set__default.default(nextModifiedDataState, [...action.keys.split("..")], action.value);
      if (!action.value) {
        nextModifiedDataState = updateConditionsToFalse(nextModifiedDataState);
      }
      set__default.default(draftState, "modifiedData", nextModifiedDataState);
      break;
    }
    case "ON_CHANGE_TOGGLE_PARENT_CHECKBOX": {
      const { keys, value } = action;
      const pathToValue = [...keys.split("..")];
      let nextModifiedDataState = cloneDeep__default.default(state.modifiedData);
      const oldValues = get__default.default(nextModifiedDataState, pathToValue, {});
      const updatedValues = updateValues(oldValues, value);
      set__default.default(nextModifiedDataState, pathToValue, updatedValues);
      if (!value) {
        nextModifiedDataState = updateConditionsToFalse(nextModifiedDataState);
      }
      set__default.default(draftState, ["modifiedData"], nextModifiedDataState);
      break;
    }
    case "RESET_FORM": {
      draftState.modifiedData = state.initialData;
      break;
    }
    case "SET_FORM_AFTER_SUBMIT": {
      draftState.initialData = state.modifiedData;
      break;
    }
    default:
      return draftState;
  }
});
const createConditionsArray = (conditions) => {
  return Object.entries(conditions).filter(([, conditionValue]) => {
    return conditionValue;
  }).map(([conditionName]) => conditionName);
};
const createPermission = (array) => {
  const [actionName, { conditions }] = array;
  return {
    action: actionName,
    subject: null,
    conditions: createConditionsArray(conditions),
    properties: {}
  };
};
const createPermissionsArrayFromCategory = (categoryPermissions) => {
  return Object.values(categoryPermissions).reduce((acc, current) => {
    const permissions = Object.entries(current).reduce((acc1, current1) => {
      const [
        ,
        {
          properties: { enabled }
        }
      ] = current1;
      if (!enabled) {
        return acc1;
      }
      const permission = createPermission(current1);
      acc1.push(permission);
      return acc1;
    }, []);
    return [...acc, ...permissions];
  }, []);
};
const formatSettingsPermissionsToAPI = (settingsPermissionsObject) => {
  return Object.values(settingsPermissionsObject).reduce((acc, current) => {
    const currentCategoryPermissions = createPermissionsArrayFromCategory(current);
    return [...acc, ...currentCategoryPermissions];
  }, []);
};
const createPropertyArray = (propertyValue, prefix = "") => {
  return Object.entries(propertyValue).reduce((acc, current) => {
    const [name, value] = current;
    if (isObject__default.default(value)) {
      return [...acc, ...createPropertyArray(value, `${prefix}${name}.`)];
    }
    if (value && !isObject__default.default(value)) {
      acc.push(`${prefix}${name}`);
    }
    return acc;
  }, []);
};
const createPermissionWithProperties = (action, subject, { conditions, properties }) => {
  return Object.entries(properties).reduce(
    (acc, current) => {
      const [propertyName, propertyValue] = current;
      acc.properties[propertyName] = createPropertyArray(propertyValue);
      return acc;
    },
    { action, subject, conditions: createConditionsArray(conditions), properties: {} }
  );
};
const createPermissionWithoutProperties = (action, subject, { conditions }) => {
  return {
    action,
    subject,
    properties: {},
    conditions: createConditionsArray(conditions)
  };
};
const createSubjectPermissions = (subject, actions) => {
  const permissions = Object.entries(actions).reduce((acc, current) => {
    const [actionName, permissions2] = current;
    const shouldCreatePermission = createArrayOfValues(permissions2).some((val) => val);
    if (!shouldCreatePermission) {
      return acc;
    }
    if (!permissions2?.properties?.enabled) {
      const createdPermissionsArray = createPermissionWithProperties(
        actionName,
        subject,
        permissions2
      );
      return [...acc, createdPermissionsArray];
    }
    if (!permissions2.properties.enabled) {
      return acc;
    }
    const permission = createPermissionWithoutProperties(actionName, subject, permissions2);
    acc.push(permission);
    return acc;
  }, []);
  return permissions;
};
const formatContentTypesPermissionToAPI = (contentTypesPermissions) => {
  const permissions = Object.entries(contentTypesPermissions).reduce((allPermissions, current) => {
    const [subject, currentSubjectActions] = current;
    const permissions2 = createSubjectPermissions(subject, currentSubjectActions);
    return [...allPermissions, ...permissions2];
  }, []);
  return permissions;
};
const formatPermissionsToAPI = (modifiedData) => {
  const pluginsPermissions = formatSettingsPermissionsToAPI(modifiedData.plugins);
  const settingsPermissions = formatSettingsPermissionsToAPI(modifiedData.settings);
  const collectionTypesPermissions = formatContentTypesPermissionToAPI(
    modifiedData.collectionTypes
  );
  const singleTypesPermissions = formatContentTypesPermissionToAPI(modifiedData.singleTypes);
  return [
    ...pluginsPermissions,
    ...settingsPermissions,
    ...collectionTypesPermissions,
    ...singleTypesPermissions
  ];
};
const TAB_LABELS = [
  {
    labelId: "app.components.LeftMenuLinkContainer.collectionTypes",
    defaultMessage: "Collection Types",
    id: "collectionTypes"
  },
  {
    labelId: "app.components.LeftMenuLinkContainer.singleTypes",
    id: "singleTypes",
    defaultMessage: "Single Types"
  },
  {
    labelId: "app.components.LeftMenuLinkContainer.plugins",
    defaultMessage: "Plugins",
    id: "plugins"
  },
  {
    labelId: "app.components.LeftMenuLinkContainer.settings",
    defaultMessage: "Settings",
    id: "settings"
  }
];
const Permissions = React.forwardRef(({ layout, isFormDisabled, permissions }, ref) => {
  const [{ initialData, layouts, modifiedData }, dispatch] = React.useReducer(
    reducer,
    initialState,
    () => init(layout, permissions)
  );
  const { formatMessage } = reactIntl.useIntl();
  React.useImperativeHandle(ref, () => {
    return {
      getPermissions() {
        const collectionTypesDiff = helperPlugin.difference(
          initialData.collectionTypes,
          modifiedData.collectionTypes
        );
        const singleTypesDiff = helperPlugin.difference(initialData.singleTypes, modifiedData.singleTypes);
        const contentTypesDiff = { ...collectionTypesDiff, ...singleTypesDiff };
        let didUpdateConditions;
        if (isEmpty__default.default(contentTypesDiff)) {
          didUpdateConditions = false;
        } else {
          didUpdateConditions = Object.values(contentTypesDiff).some((permission) => {
            return Object.values(permission).some(
              (permissionValue) => has__default.default(permissionValue, "conditions")
            );
          });
        }
        return { permissionsToSend: formatPermissionsToAPI(modifiedData), didUpdateConditions };
      },
      resetForm() {
        dispatch({ type: "RESET_FORM" });
      },
      setFormAfterSubmit() {
        dispatch({ type: "SET_FORM_AFTER_SUBMIT" });
      }
    };
  });
  const handleChangeCollectionTypeLeftActionRowCheckbox = (pathToCollectionType, propertyName, rowName, value) => {
    dispatch({
      type: "ON_CHANGE_COLLECTION_TYPE_ROW_LEFT_CHECKBOX",
      pathToCollectionType,
      propertyName,
      rowName,
      value
    });
  };
  const handleChangeCollectionTypeGlobalActionCheckbox = (collectionTypeKind, actionId, value) => {
    dispatch({
      type: "ON_CHANGE_COLLECTION_TYPE_GLOBAL_ACTION_CHECKBOX",
      collectionTypeKind,
      actionId,
      value
    });
  };
  const handleChangeConditions = (conditions) => {
    dispatch({ type: "ON_CHANGE_CONDITIONS", conditions });
  };
  const handleChangeSimpleCheckbox = React.useCallback(({ target: { name, value } }) => {
    dispatch({
      type: "ON_CHANGE_SIMPLE_CHECKBOX",
      keys: name,
      value
    });
  }, []);
  const handleChangeParentCheckbox = React.useCallback(({ target: { name, value } }) => {
    dispatch({
      type: "ON_CHANGE_TOGGLE_PARENT_CHECKBOX",
      keys: name,
      value
    });
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsx(
    PermissionsDataManagerProvider,
    {
      availableConditions: layout.conditions,
      modifiedData,
      onChangeConditions: handleChangeConditions,
      onChangeSimpleCheckbox: handleChangeSimpleCheckbox,
      onChangeParentCheckbox: handleChangeParentCheckbox,
      onChangeCollectionTypeLeftActionRowCheckbox: handleChangeCollectionTypeLeftActionRowCheckbox,
      onChangeCollectionTypeGlobalActionCheckbox: handleChangeCollectionTypeGlobalActionCheckbox,
      children: /* @__PURE__ */ jsxRuntime.jsxs(
        designSystem.TabGroup,
        {
          id: "tabs",
          label: formatMessage({
            id: "Settings.permissions.users.tabs.label",
            defaultMessage: "Tabs Permissions"
          }),
          children: [
            /* @__PURE__ */ jsxRuntime.jsx(designSystem.Tabs, { children: TAB_LABELS.map((tabLabel) => /* @__PURE__ */ jsxRuntime.jsx(designSystem.Tab, { children: formatMessage({ id: tabLabel.labelId, defaultMessage: tabLabel.defaultMessage }) }, tabLabel.id)) }),
            /* @__PURE__ */ jsxRuntime.jsxs(designSystem.TabPanels, { style: { position: "relative" }, children: [
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.TabPanel, { children: /* @__PURE__ */ jsxRuntime.jsx(
                ContentTypes$1,
                {
                  layout: layouts.collectionTypes,
                  kind: "collectionTypes",
                  isFormDisabled
                }
              ) }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.TabPanel, { children: /* @__PURE__ */ jsxRuntime.jsx(
                ContentTypes$1,
                {
                  layout: layouts.singleTypes,
                  kind: "singleTypes",
                  isFormDisabled
                }
              ) }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.TabPanel, { children: /* @__PURE__ */ jsxRuntime.jsx(
                PluginsAndSettingsPermissions,
                {
                  layout: layouts.plugins,
                  kind: "plugins",
                  isFormDisabled
                }
              ) }),
              /* @__PURE__ */ jsxRuntime.jsx(designSystem.TabPanel, { children: /* @__PURE__ */ jsxRuntime.jsx(
                PluginsAndSettingsPermissions,
                {
                  layout: layouts.settings,
                  kind: "settings",
                  isFormDisabled
                }
              ) })
            ] })
          ]
        }
      )
    }
  );
});
Permissions.defaultProps = {
  permissions: [],
  layout: {
    conditions: [],
    sections: {
      collectionTypes: {},
      singleTypes: {
        actions: []
      },
      settings: [],
      plugins: []
    }
  }
};
Permissions.propTypes = {
  layout: PropTypes__default.default.object,
  isFormDisabled: PropTypes__default.default.bool.isRequired,
  permissions: PropTypes__default.default.array
};
const Permissions$1 = React.memo(Permissions);
const useAdminRolePermissionLayout = (id, queryOptions = {}) => {
  const { get: get2 } = helperPlugin.useFetchClient();
  const { data, error, isError, isLoading } = reactQuery.useQuery(
    ["permissions", id],
    async () => {
      const {
        data: { data: data2 }
      } = await get2("/admin/permissions", {
        // TODO: check with BE why we deviate from our usual admin API format here
        params: { role: id }
      });
      return data2;
    },
    queryOptions
  );
  return { data, error, isError, isLoading };
};
const useAdminRolePermissions = (params = { id: null }, queryOptions = {}) => {
  const { id, ...queryParams } = params;
  const { get: get2 } = helperPlugin.useFetchClient();
  const {
    data: permissions,
    error,
    isError,
    isLoading,
    refetch
  } = reactQuery.useQuery(
    ["roles", id, "permissions", queryParams],
    async () => {
      const {
        data: { data }
      } = await get2(`/admin/roles/${id}/permissions`, {
        params: queryParams
      });
      return data;
    },
    queryOptions
  );
  return { permissions, error, isError, isLoading, refetch };
};
exports.Permissions = Permissions$1;
exports.useAdminRolePermissionLayout = useAdminRolePermissionLayout;
exports.useAdminRolePermissions = useAdminRolePermissions;
//# sourceMappingURL=useAdminRolePermissions-cb1a3ee2.js.map
