"use strict";
const jsxRuntime = require("react/jsx-runtime");
const designSystem = require("@strapi/design-system");
const helperPlugin = require("@strapi/helper-plugin");
const Icons = require("@strapi/icons");
const PropTypes = require("prop-types");
const reactIntl = require("react-intl");
const React = require("react");
const axios = require("axios");
const dateFns = require("date-fns");
const locales = require("date-fns/locale");
const yup = require("yup");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const PropTypes__default = /* @__PURE__ */ _interopDefault(PropTypes);
const locales__namespace = /* @__PURE__ */ _interopNamespace(locales);
const yup__namespace = /* @__PURE__ */ _interopNamespace(yup);
const useRegenerate = (url, id, onRegenerate, onError) => {
  const [isLoadingConfirmation, setIsLoadingConfirmation] = React.useState(false);
  const toggleNotification = helperPlugin.useNotification();
  const { post } = helperPlugin.useFetchClient();
  const { formatAPIError } = helperPlugin.useAPIErrorHandler();
  const regenerateData = async () => {
    try {
      const {
        data: {
          data: { accessKey }
        }
      } = await post(`${url}${id}/regenerate`);
      setIsLoadingConfirmation(false);
      onRegenerate(accessKey);
    } catch (error) {
      setIsLoadingConfirmation(false);
      if (onError) {
        onError(error);
      } else {
        if (error instanceof axios.AxiosError) {
          toggleNotification({
            type: "warning",
            message: formatAPIError(error)
          });
        }
      }
    }
  };
  return {
    regenerateData,
    isLoadingConfirmation
  };
};
const Regenerate = ({ onRegenerate, idToRegenerate, backUrl, onError }) => {
  const { formatMessage } = reactIntl.useIntl();
  const [showConfirmDialog, setShowConfirmDialog] = React.useState(false);
  const { regenerateData, isLoadingConfirmation } = useRegenerate(
    backUrl,
    idToRegenerate,
    onRegenerate,
    onError
  );
  const handleConfirmRegeneration = async () => {
    regenerateData();
    setShowConfirmDialog(false);
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      designSystem.Button,
      {
        startIcon: /* @__PURE__ */ jsxRuntime.jsx(Icons.Refresh, {}),
        type: "button",
        size: "S",
        variant: "tertiary",
        onClick: () => setShowConfirmDialog(true),
        name: "regenerate",
        children: formatMessage({
          id: "Settings.tokens.regenerate",
          defaultMessage: "Regenerate"
        })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      helperPlugin.ConfirmDialog,
      {
        bodyText: {
          id: "Settings.tokens.popUpWarning.message",
          defaultMessage: "Are you sure you want to regenerate this token?"
        },
        iconRightButton: /* @__PURE__ */ jsxRuntime.jsx(Icons.Refresh, {}),
        isConfirmButtonLoading: isLoadingConfirmation,
        isOpen: showConfirmDialog,
        onToggleDialog: () => setShowConfirmDialog(false),
        onConfirm: handleConfirmRegeneration,
        leftButtonText: {
          id: "Settings.tokens.Button.cancel",
          defaultMessage: "Cancel"
        },
        rightButtonText: {
          id: "Settings.tokens.Button.regenerate",
          defaultMessage: "Regenerate"
        },
        title: {
          id: "Settings.tokens.RegenerateDialog.title",
          defaultMessage: "Regenerate token"
        }
      }
    )
  ] });
};
Regenerate.defaultProps = { onRegenerate() {
}, onError: void 0 };
Regenerate.propTypes = {
  onRegenerate: PropTypes__default.default.func,
  idToRegenerate: PropTypes__default.default.oneOfType([PropTypes__default.default.number, PropTypes__default.default.string]).isRequired,
  backUrl: PropTypes__default.default.string.isRequired,
  onError: PropTypes__default.default.func
};
const FormHead = ({
  title,
  token,
  setToken,
  canEditInputs,
  canRegenerate,
  isSubmitting,
  backUrl,
  regenerateUrl,
  onErrorRegenerate
}) => {
  const { formatMessage } = reactIntl.useIntl();
  const handleRegenerate = (newKey) => {
    setToken({
      ...token,
      accessKey: newKey
    });
  };
  return /* @__PURE__ */ jsxRuntime.jsx(
    designSystem.HeaderLayout,
    {
      title: token?.name || formatMessage(title),
      primaryAction: canEditInputs ? /* @__PURE__ */ jsxRuntime.jsxs(designSystem.Flex, { gap: 2, children: [
        canRegenerate && token?.id && /* @__PURE__ */ jsxRuntime.jsx(
          Regenerate,
          {
            backUrl: regenerateUrl,
            onRegenerate: handleRegenerate,
            idToRegenerate: token?.id,
            onError: onErrorRegenerate
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          designSystem.Button,
          {
            disabled: isSubmitting,
            loading: isSubmitting,
            startIcon: /* @__PURE__ */ jsxRuntime.jsx(Icons.Check, {}),
            type: "submit",
            size: "S",
            children: formatMessage({
              id: "global.save",
              defaultMessage: "Save"
            })
          }
        )
      ] }) : canRegenerate && token?.id && /* @__PURE__ */ jsxRuntime.jsx(
        Regenerate,
        {
          onRegenerate: handleRegenerate,
          idToRegenerate: token?.id,
          backUrl: regenerateUrl
        }
      ),
      navigationAction: /* @__PURE__ */ jsxRuntime.jsx(helperPlugin.Link, { startIcon: /* @__PURE__ */ jsxRuntime.jsx(Icons.ArrowLeft, {}), to: backUrl, children: formatMessage({
        id: "global.back",
        defaultMessage: "Back"
      }) }),
      ellipsis: true
    }
  );
};
FormHead.propTypes = {
  token: PropTypes__default.default.shape({
    id: PropTypes__default.default.oneOfType([PropTypes__default.default.number, PropTypes__default.default.string]),
    type: PropTypes__default.default.string,
    lifespan: PropTypes__default.default.oneOfType([PropTypes__default.default.number, PropTypes__default.default.string]),
    name: PropTypes__default.default.string,
    accessKey: PropTypes__default.default.string,
    permissions: PropTypes__default.default.array,
    description: PropTypes__default.default.string,
    createdAt: PropTypes__default.default.string
  }),
  canEditInputs: PropTypes__default.default.bool.isRequired,
  canRegenerate: PropTypes__default.default.bool.isRequired,
  setToken: PropTypes__default.default.func.isRequired,
  isSubmitting: PropTypes__default.default.bool.isRequired,
  backUrl: PropTypes__default.default.string.isRequired,
  title: PropTypes__default.default.shape({
    id: PropTypes__default.default.string,
    label: PropTypes__default.default.string
  }).isRequired,
  regenerateUrl: PropTypes__default.default.string.isRequired,
  onErrorRegenerate: PropTypes__default.default.func
};
FormHead.defaultProps = {
  token: void 0,
  onErrorRegenerate: void 0
};
const TokenBox = ({ token, tokenType }) => {
  const { formatMessage } = reactIntl.useIntl();
  const toggleNotification = helperPlugin.useNotification();
  const { trackUsage } = helperPlugin.useTracking();
  const { copy } = helperPlugin.useClipboard();
  const handleClick = (token2) => async () => {
    const didCopy = await copy(token2);
    if (didCopy) {
      trackUsage("didCopyTokenKey", {
        tokenType
      });
      toggleNotification({
        type: "success",
        message: { id: "Settings.tokens.notification.copied" }
      });
    }
  };
  return /* @__PURE__ */ jsxRuntime.jsx(
    helperPlugin.ContentBox,
    {
      endAction: token && /* @__PURE__ */ jsxRuntime.jsx("span", { style: { alignSelf: "start" }, children: /* @__PURE__ */ jsxRuntime.jsx(
        designSystem.IconButton,
        {
          label: formatMessage({
            id: "app.component.CopyToClipboard.label",
            defaultMessage: "Copy to clipboard"
          }),
          onClick: handleClick(token),
          noBorder: true,
          icon: /* @__PURE__ */ jsxRuntime.jsx(Icons.Duplicate, {}),
          style: { padding: 0, height: "1rem" }
        }
      ) }),
      title: token || formatMessage({
        id: "Settings.tokens.copy.editTitle",
        defaultMessage: "This token isn’t accessible anymore."
      }),
      subtitle: token ? formatMessage({
        id: "Settings.tokens.copy.lastWarning",
        defaultMessage: "Make sure to copy this token, you won’t be able to see it again!"
      }) : formatMessage({
        id: "Settings.tokens.copy.editMessage",
        defaultMessage: "For security reasons, you can only see your token once."
      }),
      icon: /* @__PURE__ */ jsxRuntime.jsx(Icons.Key, {}),
      iconBackground: "neutral100"
    }
  );
};
TokenBox.defaultProps = {
  token: null
};
TokenBox.propTypes = {
  token: PropTypes__default.default.string,
  tokenType: PropTypes__default.default.string.isRequired
};
const getDateOfExpiration = (createdAt, duration, language = "en") => {
  if (duration && typeof duration === "number") {
    const durationInDays = duration / 24 / 60 / 60 / 1e3;
    return dateFns.format(dateFns.addDays(new Date(createdAt), durationInDays), "PPP", {
      locale: locales__namespace[language]
    });
  }
  return "Unlimited";
};
const schema = yup__namespace.object().shape({
  name: yup__namespace.string(helperPlugin.translatedErrors.string).max(100).required(helperPlugin.translatedErrors.required),
  type: yup__namespace.string(helperPlugin.translatedErrors.string).oneOf(["read-only", "full-access", "custom"]).required(helperPlugin.translatedErrors.required),
  description: yup__namespace.string().nullable(),
  lifespan: yup__namespace.number().integer().min(0).nullable().defined(helperPlugin.translatedErrors.required)
});
const LifeSpanInput = ({ token, errors, values, onChange, isCreating }) => {
  const { formatMessage } = reactIntl.useIntl();
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      designSystem.Select,
      {
        name: "lifespan",
        label: formatMessage({
          id: "Settings.tokens.form.duration",
          defaultMessage: "Token duration"
        }),
        value: values.lifespan !== null ? values.lifespan : "0",
        error: errors.lifespan ? formatMessage(
          errors.lifespan?.id ? errors.lifespan : { id: errors.lifespan, defaultMessage: errors.lifespan }
        ) : null,
        onChange: (value) => {
          onChange({ target: { name: "lifespan", value } });
        },
        required: true,
        disabled: !isCreating,
        placeholder: "Select",
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Option, { value: "604800000", children: formatMessage({
            id: "Settings.tokens.duration.7-days",
            defaultMessage: "7 days"
          }) }),
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Option, { value: "2592000000", children: formatMessage({
            id: "Settings.tokens.duration.30-days",
            defaultMessage: "30 days"
          }) }),
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Option, { value: "7776000000", children: formatMessage({
            id: "Settings.tokens.duration.90-days",
            defaultMessage: "90 days"
          }) }),
          /* @__PURE__ */ jsxRuntime.jsx(designSystem.Option, { value: "0", children: formatMessage({
            id: "Settings.tokens.duration.unlimited",
            defaultMessage: "Unlimited"
          }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(designSystem.Typography, { variant: "pi", textColor: "neutral600", children: !isCreating && `${formatMessage({
      id: "Settings.tokens.duration.expiration-date",
      defaultMessage: "Expiration date"
    })}: ${getDateOfExpiration(token?.createdAt, parseInt(values.lifespan, 10))}` })
  ] });
};
LifeSpanInput.propTypes = {
  errors: PropTypes__default.default.shape({
    lifespan: PropTypes__default.default.string
  }),
  onChange: PropTypes__default.default.func.isRequired,
  values: PropTypes__default.default.shape({
    lifespan: PropTypes__default.default.oneOfType([PropTypes__default.default.number, PropTypes__default.default.string])
  }).isRequired,
  isCreating: PropTypes__default.default.bool.isRequired,
  token: PropTypes__default.default.shape({
    id: PropTypes__default.default.oneOfType([PropTypes__default.default.number, PropTypes__default.default.string]),
    type: PropTypes__default.default.string,
    lifespan: PropTypes__default.default.string,
    name: PropTypes__default.default.string,
    accessKey: PropTypes__default.default.string,
    permissions: PropTypes__default.default.array,
    description: PropTypes__default.default.string,
    createdAt: PropTypes__default.default.string
  })
};
LifeSpanInput.defaultProps = {
  errors: {},
  token: {}
};
const TokenDescription = ({ errors, values, onChange, canEditInputs }) => {
  const { formatMessage } = reactIntl.useIntl();
  return /* @__PURE__ */ jsxRuntime.jsx(
    designSystem.Textarea,
    {
      label: formatMessage({
        id: "Settings.tokens.form.description",
        defaultMessage: "Description"
      }),
      id: "description",
      error: errors.description ? formatMessage(
        errors.description?.id ? errors.description : {
          id: errors.description,
          defaultMessage: errors.description
        }
      ) : null,
      onChange,
      disabled: !canEditInputs,
      children: values.description
    }
  );
};
TokenDescription.propTypes = {
  errors: PropTypes__default.default.shape({
    description: PropTypes__default.default.string
  }),
  onChange: PropTypes__default.default.func.isRequired,
  canEditInputs: PropTypes__default.default.bool.isRequired,
  values: PropTypes__default.default.shape({
    description: PropTypes__default.default.string
  }).isRequired
};
TokenDescription.defaultProps = {
  errors: {}
};
const TokenName = ({ errors, values, onChange, canEditInputs }) => {
  const { formatMessage } = reactIntl.useIntl();
  return /* @__PURE__ */ jsxRuntime.jsx(
    designSystem.TextInput,
    {
      name: "name",
      error: errors.name ? formatMessage(
        errors.name?.id ? errors.name : { id: errors.name, defaultMessage: errors.name }
      ) : null,
      label: formatMessage({
        id: "Settings.tokens.form.name",
        defaultMessage: "Name"
      }),
      onChange,
      value: values.name,
      disabled: !canEditInputs,
      required: true
    }
  );
};
TokenName.propTypes = {
  errors: PropTypes__default.default.shape({
    name: PropTypes__default.default.string
  }),
  onChange: PropTypes__default.default.func.isRequired,
  canEditInputs: PropTypes__default.default.bool.isRequired,
  values: PropTypes__default.default.shape({
    name: PropTypes__default.default.string
  }).isRequired
};
TokenName.defaultProps = {
  errors: {}
};
const TokenTypeSelect = ({ name, errors, values, onChange, canEditInputs, options, label }) => {
  const { formatMessage } = reactIntl.useIntl();
  return /* @__PURE__ */ jsxRuntime.jsx(
    designSystem.Select,
    {
      name,
      label: formatMessage({
        id: label.id,
        defaultMessage: label.defaultMessage
      }),
      value: values && values[name],
      error: errors[name] ? formatMessage(
        errors[name]?.id ? errors[name] : { id: errors[name], defaultMessage: errors[name] }
      ) : null,
      onChange,
      placeholder: "Select",
      required: true,
      disabled: !canEditInputs,
      children: options && options.map(({ value, label: label2 }) => /* @__PURE__ */ jsxRuntime.jsx(designSystem.Option, { value, children: formatMessage(label2) }, value))
    }
  );
};
TokenTypeSelect.propTypes = {
  name: PropTypes__default.default.string,
  options: PropTypes__default.default.arrayOf(
    PropTypes__default.default.shape({
      label: PropTypes__default.default.shape({
        id: PropTypes__default.default.string,
        defaultMessage: PropTypes__default.default.string
      }),
      value: PropTypes__default.default.string
    })
  ),
  errors: PropTypes__default.default.shape({
    type: PropTypes__default.default.string
  }),
  onChange: PropTypes__default.default.func.isRequired,
  canEditInputs: PropTypes__default.default.bool.isRequired,
  values: PropTypes__default.default.shape({
    type: PropTypes__default.default.string
  }).isRequired,
  label: PropTypes__default.default.shape({
    id: PropTypes__default.default.string,
    defaultMessage: PropTypes__default.default.string
  }).isRequired
};
TokenTypeSelect.defaultProps = {
  name: "type",
  errors: {},
  options: []
};
exports.FormHead = FormHead;
exports.LifeSpanInput = LifeSpanInput;
exports.TokenBox = TokenBox;
exports.TokenDescription = TokenDescription;
exports.TokenName = TokenName;
exports.TokenTypeSelect = TokenTypeSelect;
exports.schema = schema;
//# sourceMappingURL=index-d3e1fd86.js.map
