import { jsxs, jsx } from "react/jsx-runtime";
import { Box, IconButton, Tbody, Tr, Td, Typography, Flex } from "@strapi/design-system";
import { useTracking, ConfirmDialog, Link, DynamicTable, useQueryParams, onRowClick, pxToRem, RelativeTime } from "@strapi/helper-plugin";
import PropTypes from "prop-types";
import { useIntl } from "react-intl";
import { useHistory } from "react-router-dom";
import { useState } from "react";
import { Trash, Eye, Pencil } from "@strapi/icons";
import styled from "styled-components";
const DeleteButton = ({ tokenName, onClickDelete, tokenType }) => {
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const handleClickDelete = () => {
    setShowConfirmDialog(false);
    trackUsage("willDeleteToken", {
      tokenType
    });
    onClickDelete();
  };
  return /* @__PURE__ */ jsxs(Box, { paddingLeft: 1, onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsx(
      IconButton,
      {
        onClick: () => {
          setShowConfirmDialog(true);
        },
        label: formatMessage(
          {
            id: "global.delete-target",
            defaultMessage: "Delete {target}"
          },
          { target: `${tokenName}` }
        ),
        name: "delete",
        noBorder: true,
        icon: /* @__PURE__ */ jsx(Trash, {})
      }
    ),
    /* @__PURE__ */ jsx(
      ConfirmDialog,
      {
        onToggleDialog: () => setShowConfirmDialog(false),
        onConfirm: handleClickDelete,
        isOpen: showConfirmDialog
      }
    )
  ] });
};
DeleteButton.propTypes = {
  tokenName: PropTypes.string.isRequired,
  onClickDelete: PropTypes.func.isRequired,
  tokenType: PropTypes.string.isRequired
};
const MESSAGES_MAP = {
  edit: {
    id: "app.component.table.edit",
    defaultMessage: "Edit {target}"
  },
  read: {
    id: "app.component.table.read",
    defaultMessage: "Read {target}"
  }
};
const LinkStyled = styled(Link)`
  svg {
    path {
      fill: ${({ theme }) => theme.colors.neutral500};
    }
  }

  &:hover,
  &:focus {
    svg {
      path {
        fill: ${({ theme }) => theme.colors.neutral800};
      }
    }
  }
`;
const DefaultButton = ({ tokenName, tokenId, buttonType, children }) => {
  const { formatMessage } = useIntl();
  const {
    location: { pathname }
  } = useHistory();
  return /* @__PURE__ */ jsx(
    LinkStyled,
    {
      to: `${pathname}/${tokenId}`,
      title: formatMessage(MESSAGES_MAP[buttonType], { target: tokenName }),
      children
    }
  );
};
DefaultButton.propTypes = {
  tokenName: PropTypes.string.isRequired,
  tokenId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
  buttonType: PropTypes.string,
  children: PropTypes.node.isRequired
};
DefaultButton.defaultProps = {
  buttonType: "edit"
};
const ReadButton = ({ tokenName, tokenId }) => {
  return /* @__PURE__ */ jsx(DefaultButton, { tokenName, tokenId, buttonType: "read", children: /* @__PURE__ */ jsx(Eye, {}) });
};
ReadButton.propTypes = {
  tokenName: PropTypes.string.isRequired,
  tokenId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired
};
const UpdateButton = ({ tokenName, tokenId }) => {
  return /* @__PURE__ */ jsx(DefaultButton, { tokenName, tokenId, children: /* @__PURE__ */ jsx(Pencil, {}) });
};
UpdateButton.propTypes = {
  tokenName: PropTypes.string.isRequired,
  tokenId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired
};
const Table = ({
  permissions,
  headers,
  contentType,
  isLoading,
  tokens,
  onConfirmDelete,
  tokenType
}) => {
  const { canDelete, canUpdate, canRead } = permissions;
  return /* @__PURE__ */ jsx(
    DynamicTable,
    {
      headers,
      contentType,
      rows: tokens,
      withBulkActions: canDelete || canUpdate || canRead,
      isLoading,
      onConfirmDelete,
      children: /* @__PURE__ */ jsx(
        TableRows,
        {
          tokenType,
          permissions,
          onConfirmDelete
        }
      )
    }
  );
};
Table.propTypes = {
  tokens: PropTypes.array,
  permissions: PropTypes.shape({
    canRead: PropTypes.bool,
    canDelete: PropTypes.bool,
    canUpdate: PropTypes.bool
  }).isRequired,
  headers: PropTypes.arrayOf(
    PropTypes.shape({
      cellFormatter: PropTypes.func,
      key: PropTypes.string.isRequired,
      metadatas: PropTypes.shape({
        label: PropTypes.string.isRequired,
        sortable: PropTypes.bool
      }).isRequired,
      name: PropTypes.string.isRequired
    })
  ),
  contentType: PropTypes.string.isRequired,
  isLoading: PropTypes.bool,
  onConfirmDelete: PropTypes.func,
  tokenType: PropTypes.string.isRequired
};
Table.defaultProps = {
  tokens: [],
  headers: [],
  isLoading: false,
  onConfirmDelete() {
  }
};
const TableRows = ({ tokenType, permissions, rows, withBulkActions, onConfirmDelete }) => {
  const { canDelete, canUpdate, canRead } = permissions;
  const [{ query }] = useQueryParams();
  const { formatMessage } = useIntl();
  const [, sortOrder] = query ? query.sort.split(":") : "ASC";
  const {
    push,
    location: { pathname }
  } = useHistory();
  const { trackUsage } = useTracking();
  const sortedTokens = rows.sort((a, b) => {
    const comparison = a.name.localeCompare(b.name);
    return sortOrder === "DESC" ? -comparison : comparison;
  });
  return /* @__PURE__ */ jsx(Tbody, { children: sortedTokens.map((token) => {
    return /* @__PURE__ */ jsxs(
      Tr,
      {
        ...onRowClick({
          fn() {
            trackUsage("willEditTokenFromList", {
              tokenType
            });
            push(`${pathname}/${token.id}`);
          },
          condition: canUpdate
        }),
        children: [
          /* @__PURE__ */ jsx(Td, { maxWidth: pxToRem(250), children: /* @__PURE__ */ jsx(Typography, { textColor: "neutral800", fontWeight: "bold", ellipsis: true, children: token.name }) }),
          /* @__PURE__ */ jsx(Td, { maxWidth: pxToRem(250), children: /* @__PURE__ */ jsx(Typography, { textColor: "neutral800", ellipsis: true, children: token.description }) }),
          /* @__PURE__ */ jsx(Td, { children: /* @__PURE__ */ jsx(Typography, { textColor: "neutral800", children: /* @__PURE__ */ jsx(RelativeTime, { timestamp: new Date(token.createdAt) }) }) }),
          /* @__PURE__ */ jsx(Td, { children: token.lastUsedAt && /* @__PURE__ */ jsx(Typography, { textColor: "neutral800", children: /* @__PURE__ */ jsx(
            RelativeTime,
            {
              timestamp: new Date(token.lastUsedAt),
              customIntervals: [
                {
                  unit: "hours",
                  threshold: 1,
                  text: formatMessage({
                    id: "Settings.apiTokens.lastHour",
                    defaultMessage: "last hour"
                  })
                }
              ]
            }
          ) }) }),
          withBulkActions && /* @__PURE__ */ jsx(Td, { children: /* @__PURE__ */ jsxs(Flex, { justifyContent: "end", children: [
            canUpdate && /* @__PURE__ */ jsx(UpdateButton, { tokenName: token.name, tokenId: token.id }),
            !canUpdate && canRead && /* @__PURE__ */ jsx(ReadButton, { tokenName: token.name, tokenId: token.id }),
            canDelete && /* @__PURE__ */ jsx(
              DeleteButton,
              {
                tokenName: token.name,
                onClickDelete: () => onConfirmDelete(token.id),
                tokenType
              }
            )
          ] }) })
        ]
      },
      token.id
    );
  }) });
};
TableRows.defaultProps = {
  rows: [],
  withBulkActions: false
};
TableRows.propTypes = {
  rows: PropTypes.array,
  permissions: PropTypes.shape({
    canRead: PropTypes.bool,
    canDelete: PropTypes.bool,
    canUpdate: PropTypes.bool
  }).isRequired,
  onConfirmDelete: PropTypes.func.isRequired,
  tokenType: PropTypes.string.isRequired,
  withBulkActions: PropTypes.bool
};
export {
  Table as T
};
//# sourceMappingURL=index-eb67694f.mjs.map
